From Linden Require Import TMatching Tree Chars Semantics MSInput
  Regex LindenParameters RegexpTranslation ListLemmas
  WarblreLemmas Tactics LWEquivTreeLemmas LWEquivTMatcher LWEquivTMatcherLemmas NumericLemmas.
From Warblre Require Import Result Notation RegExpRecord Match Base
  Patterns Node NodeProps Semantics.
From Coq Require Import List ZArith Lia.
Import Notation.
Import Result.Notations.
Import Match.MatchState.
Import ListNotations.
Import Patterns.
Import Zipper.
Import Zipper.Down.

Local Open Scope result_flow.

(** * Theorems for second part of equivalence: the trees generated by tCompileSubPattern are valid trees wrt the Linden semantics. *)


(** ** Definition of the validity of tree matchers and tree matcher continuations *)

(* `tMC_is_tree tmc rer cont inp` means that the TMatcherContinuation tmc, when run with a MatchState
  compatible with input inp and valid with respect to rer, performs the actions in the continuation cont and yields a valid backtree. *)
Definition tMC_is_tree (tmc: TMatcherContinuation) (rer: RegExpRecord) (cont: continuation) (inp: input) :=
  forall (ms: MatchState) (t: tree),
    (* Valid (MatchState.input ms) rer ms -> *) (* Testing *)
    ms_matches_inp ms inp ->
    tmc ms = Success t ->
    is_tree Epsilon cont inp t.

(* `tMC_valid tmc rer cont str0` means that the TMatcherContinuation tmc, when run on any input compatible with the string str0 under the flags in rer,
   performs the actions in the continuation cont and yields a valid backtree. *)
Definition tMC_valid (tmc: TMatcherContinuation) (rer: RegExpRecord) (cont: continuation) (str0: string) :=
  forall inp, input_compat inp str0 -> tMC_is_tree tmc rer cont inp.

(* `tm_valid tm rer lreg` means that under the given RegExpRecord (set of flags), the TMatcher tm recognizes the regexp lreg on any input, and yields a valid backtree. *)
Definition tm_valid (tm: TMatcher) (rer: RegExpRecord) (lreg: regex) :=
  forall (tmc: TMatcherContinuation) (cont: continuation) (str0: string),
  tMC_valid tmc rer cont str0 ->
  tMC_valid (fun s => tm s tmc) rer (Areg lreg::cont) str0.


(* Validity of empty continuation *)
Lemma id_tmcont_valid:
  forall rer str, tMC_valid id_tmcont rer [] str.
Proof.
  intros rer str inp Hinp_compat ms t Hmsinp Heqt.
  injection Heqt as <-. apply tree_epsilon.
Qed.


(** ** Lemmas for repeated matching: *)
(* Lemma for the case where the min is nonzero *)
Lemma tRepeatMatcher'_minnonzero_valid:
  (* For all repeat matcher parameters (except min), *)
  forall rer greedy parenIndex parenCount plus,
  forall (tm: TMatcher) (lreg: regex),
    (* if the TMatcher tm is valid wrt lreg, *)
    tm_valid tm rer lreg ->
    (* the list of capture groups of lreg matches the repeat matcher parameters, *)
    def_groups lreg = List.seq (parenIndex + 1) parenCount ->
    (* and the repeat matcher with min=0 is valid wrt Quantified greedy 0 plus lreg, *)
    (forall fuel, tm_valid (fun s tmc => tRepeatMatcher' tm 0 plus greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy 0 plus lreg)) ->
    (* then all repeat matchers with any min are valid wrt Quantified greedy min plus lreg. *)
    forall mini fuel, tm_valid (fun s tmc => tRepeatMatcher' tm mini (NoI.N mini + plus)%NoI greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy mini plus lreg).
Proof.
  intros rer greedy parenIndex parenCount plus tm lreg Htm_valid Hgroups_valid Hminzero_valid.
  intro mini. induction mini as [|mini' IHmini'].
  1: { simpl. replace (match plus with | NoI.N r' => _ | +∞ => _ end) with plus by now destruct plus. apply Hminzero_valid. }

  intros [|fuel].
  1: { simpl. now constructor. }
  unfold tm_valid. intros tmc cont str0 Htmc_valid. unfold tMC_valid. intros inp Hinp_compat. unfold tMC_is_tree. intros ms t Hmsinp.
  simpl.
  replace (match plus with | NoI.N r' => _ | +∞ => _ end =? NoI.N (nat_to_nni 0))%NoI with false by now destruct plus.
  destruct List.List.Update.Nat.Batch.update as [cap'|] eqn:Hcapsucc; simpl. 2: discriminate.
  replace (mini' - 0) with mini' by lia.
  pose proof mini_plus_plusminus_one mini' plus as Hplusminusone. simpl in Hplusminusone. rewrite Hplusminusone. clear Hplusminusone.
  set (nextplus := match plus with | NoI.N r' => _ | +∞ => _ end).
  set (tmcnext := fun y => _).
  unfold tm_valid in Htm_valid. specialize (Htm_valid tmcnext (Areg (Regex.Quantified greedy mini' plus lreg)::cont) str0).
  specialize_prove Htm_valid. {
    specialize (IHmini' fuel tmc cont str0 Htmc_valid). simpl in IHmini'. (* Morally, apply IHmini', but there is a monad rewrite under a lambda which we cannot do... *)
    unfold tMC_valid, tMC_is_tree. intros inp' Hinp'compat ms' t' Hms'inp.
    unfold tmcnext. rewrite (@monad_id _ _ Errors.match_assertion_error). now apply IHmini'.
  }
  unfold tMC_valid in Htm_valid. specialize (Htm_valid inp Hinp_compat).
  set (msreset := match_state _ _ cap'). unfold tMC_is_tree in Htm_valid.
  specialize (Htm_valid msreset).
  destruct tm as [subtree|]; simpl. 2: discriminate.
  specialize (Htm_valid subtree). 2: reflexivity. (* ??? *)
  (*specialize_prove Htm_valid. { eapply capture_reset_preserve_validity with (x := ms); eauto. }*)
  specialize_prove Htm_valid. { apply ms_matches_inp_capchg with (cap := MatchState.captures ms). now destruct ms. }
  specialize (Htm_valid eq_refl).
  intro Heqt. injection Heqt as <-.
  apply tree_pop_reg. apply tree_quant_minpos. 1: congruence. now inversion Htm_valid.
Qed.


(* Lemma for the case where both the min and the max are zero *)
Lemma tRepeatMatcher'_zero_valid:
  forall rer greedy parenIndex parenCount,
  forall (tm: TMatcher) (lreg: regex),
    tm_valid tm rer lreg ->
    def_groups lreg = List.seq (parenIndex + 1) parenCount ->
    forall fuel, tm_valid (fun s tmc => tRepeatMatcher' tm 0 (NoI.N 0) greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy 0 (NoI.N 0) lreg).
Proof.
  intros rer greedy parenIndex parenCount tm lreg Htmvalid Hgroupsvalid fuel.
  destruct fuel as [|fuel]. 1: discriminate.
  simpl. unfold tm_valid, tMC_valid, tMC_is_tree. intros tmc cont str0 Htmctree inp Hinpcompat ms t Hmsinp Heqt.
  apply tree_pop_reg. apply tree_quant_minzero_pluszero. eapply Htmctree; eauto.
Qed.
  

(* Lemma for the case where the min is zero but the max is arbitrary *)
Lemma tRepeatMatcher'_minzero_valid:
  forall rer greedy parenIndex parenCount,
  forall (tm: TMatcher) (lreg: regex),
    tm_valid tm rer lreg ->
    def_groups lreg = List.seq (parenIndex + 1) parenCount ->
    forall fuel plus, tm_valid (fun s tmc => tRepeatMatcher' tm 0 plus greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy 0 plus lreg).
Proof.
  intros rer greedy parenIndex parenCount tm lreg Htmvalid Hgroupsvalid fuel.
  induction fuel as [|fuel IHfuel].
  1: discriminate.

  intro plus.
  destruct (plus =? NoI.N (nat_to_nni 0))%NoI eqn:Hpluszero.
  1: { rewrite noi_eqb_eq in Hpluszero. subst plus. now apply tRepeatMatcher'_zero_valid. }
  simpl. rewrite Hpluszero.
  intros tmc cont str0 Htmc_valid inp Hinp_compat ms t Hms_inp HmatchSuccess.
  destruct List.List.Update.Nat.Batch.update as [cap'|] eqn:Heqcap'; simpl in *. 2: discriminate.
  set (tmcloop := fun y: MatchState => if (_ =? _)%Z then _ else _) in HmatchSuccess.
  set (msreset := match_state _ _ cap') in HmatchSuccess.
  assert (tMC_valid tmcloop rer (Acheck (ms_suffix ms)::Areg (Regex.Quantified greedy 0 (plus - 1)%NoI lreg)::cont) str0) as Htmcloop_valid. {
    intros inp' Hinp'_compat ms1 t1 Hms1_inp Htmcloop_succeeds.
    unfold tmcloop in Htmcloop_succeeds.
    destruct (_ =? _)%Z eqn:Heqcheck.
    - (* Case 1: the input has not progressed *)
      injection Htmcloop_succeeds as <-. apply tree_pop_check_fail.
      rewrite ms_suffix_current_str with (ms := ms1) by assumption.
      unfold ms_suffix.
      rewrite Z.eqb_eq in Heqcheck.
      rewrite Heqcheck.
      f_equal.
      eapply inp_compat_ms_same_inp with (inp1 := inp') (inp2 := inp); eauto.
    - (* Case 2: the input has progressed *)
      destruct tRepeatMatcher' as [subtree|] eqn:Heqsubtree; simpl in *.
      2: discriminate.
      injection Htmcloop_succeeds as <-.
      apply tree_pop_check.
      + eapply endInd_neq_advanced; eauto.
      + rewrite noi_decr in Heqsubtree. specialize (IHfuel (plus - 1)%NoI tmc cont str0 Htmc_valid inp' Hinp'_compat ms1 subtree Hms1_inp Heqsubtree). apply IHfuel.
  }
  specialize (Htmvalid tmcloop (Acheck (ms_suffix ms)::Areg (Regex.Quantified greedy 0 (plus-1)%NoI lreg)::cont) str0 Htmcloop_valid inp Hinp_compat).
  specialize (Htmc_valid inp Hinp_compat).
  unfold tMC_is_tree in Htmvalid, Htmc_valid.
  (*assert (Valid (MatchState.input msreset) rer msreset) as Hvalidmsreset. {
    now apply @capture_reset_preserve_validity with (specParameters := LindenParameters) (parenIndex := parenIndex) (parenCount := parenCount) (x := ms).
  }*)
  assert (ms_matches_inp msreset inp) as Hmsreset_inp. {
    unfold msreset. inversion Hms_inp. simpl. now constructor.
  }

  destruct greedy.
  + (* Greedy star *)
    destruct tm as [z|] eqn:Heqz; simpl. 2: discriminate.
    destruct tmc as [z'|] eqn:Heqz'; simpl. 2: discriminate.
    specialize (Htmvalid msreset z Hmsreset_inp Heqz).
    specialize (Htmc_valid ms z' Hms_inp Heqz').
    apply tree_pop_reg.
    rewrite noi_nonzero_succprec with (x := plus). 2: now apply noi_eqb_neq.
    eapply tree_quant_minzero_pluspos.
    * symmetry. apply Hgroupsvalid.
    * rewrite ms_suffix_current_str with (ms := ms). 2: assumption.
      inversion Htmvalid.
      apply TREECONT.
    * apply Htmc_valid.
    * inversion HmatchSuccess. reflexivity.

  + (* Lazy star *)
    destruct tmc as [z'|] eqn:Heqz'; simpl. 2: discriminate.
    destruct tm as [z|] eqn:Heqz; simpl. 2: discriminate.
    specialize (Htmvalid msreset z Hmsreset_inp Heqz).
    specialize (Htmc_valid ms z' Hms_inp Heqz').
    apply tree_pop_reg.
    rewrite noi_nonzero_succprec with (x := plus). 2: now apply noi_eqb_neq.
    eapply tree_quant_minzero_pluspos.
    * symmetry. apply Hgroupsvalid.
    * rewrite ms_suffix_current_str with (ms := ms). 2: assumption.
      inversion Htmvalid. apply TREECONT.
    * apply Htmc_valid.
    * inversion HmatchSuccess. reflexivity.
Qed.

(* Main theorem for repeated matching *)
Lemma tRepeatMatcher'_valid:
  (* for all repeat matcher parameters, *)
  forall rer greedy parenIndex parenCount mini plus,
    (* for any TMatcher tm that is valid with respect to some Linden regex lreg, *)
  forall (tm: TMatcher) (lreg: regex),
    tm_valid tm rer lreg ->
    (* such that the defined groups of lreg correspond to the capture reset parameters of the repeat matcher, *)
    def_groups lreg = List.seq (parenIndex + 1) parenCount ->
    (* the corresponding tree repeat matcher recognizes lreg quantified accordingly to the parameters (for any fuel, provided the matcher does not run out of fuel). *)
    forall fuel, tm_valid (fun s tmc => tRepeatMatcher' tm mini (NoI.N mini + plus)%NoI greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy mini plus lreg).
Proof.
  intros rer greedy parenIndex parenCount mini plus tm lreg Htmvalid Hgroupsvalid fuel.
  destruct mini as [|mini'].
  - replace (NoI.N 0 + plus)%NoI with plus by now destruct plus. now apply tRepeatMatcher'_minzero_valid.
  - apply tRepeatMatcher'_minnonzero_valid; auto. intro fuel0. now apply tRepeatMatcher'_minzero_valid.
Qed.


(** ** Main theorem *)
(* We place ourselves in the context of some root regex, and prove the validity for all the sub-regexes of the root regex. *)
Theorem tmatcher_bt:
  forall (rer: RegExpRecord) (lroot: regex) (wroot: Regex)
    (* Assume that we do not ignore case. *)
    (Hcasesenst: RegExpRecord.ignoreCase rer = false)
    (* Let lroot and wroot be a pair of equivanent regexes. *)
    (root_equiv: equiv_regex wroot lroot),
    (* Then for any sub-regex wreg of the root Warblre regex, *)
  forall (wreg: Regex) (lreg: regex) ctx,
    Root wroot (wreg, ctx) ->
    (* and any Linden regex lreg that is equivalent to this sub-regex with the right number of left capturing parentheses before, *)
    equiv_regex' wreg lreg (StaticSemantics.countLeftCapturingParensBefore wreg ctx) ->
    forall tm,
      (* if tCompileSubPattern yields a TMatcher for regex wreg, *)
      tCompileSubPattern wreg ctx rer forward = Success tm ->
      (* this TMatcher is valid with respect to the regex lreg. *)
      tm_valid tm rer lreg.
Proof.
  intros rer lroot wroot Hcasesenst root_equiv wreg lreg ctx Hroot Hequiv.
  remember (StaticSemantics.countLeftCapturingParensBefore _ _) as n in Hequiv.
  revert ctx Hroot Heqn.
  induction Hequiv as [
    n |
    n c |
    (*n |*) (* Dot *)
    n wr1 wr2 lr1 lr2 Hequiv1 IH1 Hequiv2 IH2 |
    n wr1 wr2 lr1 lr2 Hequiv1 IH1 Hequiv2 IH2 |
    n wr lr wquant lquant wgreedylazy greedy Hequiv IH Hequivquant Hequivgreedy |
    name n wr lr Hequiv IH |
    n wr lr wlk llk Hequiv IH Hequivlk
  ].


  - (* Empty *)
    simpl. intros _ _ _.
    intros tm Hcompsucc tmc cont str0 Htmc_tree inp Hinp_compat.
    injection Hcompsucc as <-.
    intros ms t Hms_inp Htmc_succ.
    apply tree_pop_reg. unfold tMC_valid, tMC_is_tree in Htmc_tree.
    now apply Htmc_tree with (ms := ms).


  - (* Character *)
    simpl.
    intros ctx Hroot _ tm Hcompile_succ tmc cont str0 Htmc_tree inp Hinp_compat ms t Hms_inp Htm_succ.
    injection Hcompile_succ as <-.
    unfold tCharacterSetMatcher in Htm_succ. simpl in Htm_succ.
    set (next_outofbounds := ((_ <? 0)%Z || _)%bool) in Htm_succ.
    destruct next_outofbounds eqn:Hoob; simpl.
    + injection Htm_succ as <-.
      apply tree_pop_reg.
      apply tree_char_fail.
      (* Reading out of bounds fails *)
      eapply read_oob_fail_bool; eauto.
    + replace (Z.min _ _) with (@MatchState.endIndex Chars.Char char_marker ms) in Htm_succ by lia.
      (* If we are in bounds, then getting the character should succeed. Since we don't prove anything in the case of errors, we just assume this here *)
      destruct List.List.Indexing.Int.indexing as [chr|err] eqn:Hgetchr; simpl in *.
      2: discriminate.
      (* Either the character is equal to the character in the regex, or it is not. *)
      destruct CharSet.exist_canonicalized eqn:Hcharmatch; simpl in *.
      * (* Case 1: it is equal. *)
        (* We then want to prove that we have a read success. *)
        apply tree_pop_reg.
        (* We first need to replace t with Success (Read chr child). *)
        remember (match_state _ _ _) as ms_adv in Htm_succ.
        unfold tMC_valid, tMC_is_tree in Htmc_tree.
        destruct (tmc ms_adv) as [child|] eqn:Htmc_succ; simpl in *. 2: discriminate.
        injection Htm_succ as <-.

        (* Now we apply tree_char with the next input, whose existence we need to prove. *)
        pose proof next_inbounds_nextinp ms inp Hms_inp Hoob as Hnextinp.
        destruct Hnextinp as [inp_adv Hnextinp].
        apply tree_char with (nextinp := inp_adv).
        1:  eapply read_char_success; eassumption.
        (* The subtree is valid: results from three lemmas. *)
        apply Htmc_tree with (ms := ms_adv).
        -- eapply advance_input_compat; eassumption.
        -- eapply ms_matches_inp_adv; eauto.
        -- assumption.
      * (* Case 2: it is not equal. *)
        injection Htm_succ as <-.
        apply tree_pop_reg.
        apply tree_char_fail.
        eapply read_char_fail; eauto.

  (* Dot *)
  (*- admit.*)


  - (* Disjunction *)
    intros ctx Hroot Heqn.
    simpl in *.
    specialize (IH1 (Disjunction_left wr2 :: ctx)).
    specialize (IH2 (Disjunction_right wr1 :: ctx)).
    specialize_prove IH1 by eauto using same_root_down0, Down_Disjunction_left.
    specialize_prove IH1. {
      simpl. unfold StaticSemantics.countLeftCapturingParensBefore in *. lia.
    }
    specialize_prove IH2 by eauto using same_root_down0, Down_Disjunction_right.
    specialize_prove IH2. {
      unfold StaticSemantics.countLeftCapturingParensBefore in *. simpl.
      assert (num_groups lr1 = StaticSemantics.countLeftCapturingParensWithin_impl wr1) by (eapply num_groups_equiv; eassumption).
      lia.
    }
    intros tm Hcompsucc.
    destruct (tCompileSubPattern wr1 _ rer forward) as [tm1|] eqn:Htm1; simpl. 2: discriminate.
    destruct (tCompileSubPattern wr2 _ rer forward) as [tm2|] eqn:Htm2; simpl. 2: discriminate.
    simpl in Hcompsucc. injection Hcompsucc as <-.
    intros tmc cont str0 Htmc_tree inp Hinp_compat s t Hs_inp Heqt.
    specialize (IH1 tm1 eq_refl tmc cont str0 Htmc_tree inp Hinp_compat).
    specialize (IH2 tm2 eq_refl tmc cont str0 Htmc_tree inp Hinp_compat).
    destruct (tm1 s tmc) as [t1|] eqn:Heqt1; simpl. 2: discriminate.
    destruct (tm2 s tmc) as [t2|] eqn:Heqt2; simpl. 2: discriminate.
    specialize (IH1 s t1 Hs_inp). specialize (IH2 s t2 Hs_inp).
    simpl in *.
    rewrite Heqt1 in IH1. rewrite Heqt2 in IH2.
    apply tree_pop_reg.
    injection Heqt as <-.
    specialize (IH1 eq_refl). specialize (IH2 eq_refl).
    inversion IH1. inversion IH2.
    now apply tree_disj.


  - (* Sequence *)
    intros ctx Hroot Heqn. simpl in *. intros tm Hcompsucc.
    specialize (IH1 (Seq_left wr2 :: ctx)).
    specialize (IH2 (Seq_right wr1 :: ctx)).
    specialize_prove IH1 by eauto using same_root_down0, Down_Seq_left.
    specialize_prove IH1. {
      unfold StaticSemantics.countLeftCapturingParensBefore in *.
      simpl.
      lia.
    }
    specialize_prove IH2 by eauto using same_root_down0, Down_Seq_right.
    specialize_prove IH2. {
      unfold StaticSemantics.countLeftCapturingParensBefore in *.
      simpl.
      assert (H: num_groups lr1 = StaticSemantics.countLeftCapturingParensWithin_impl wr1) by (eapply num_groups_equiv; eassumption).
      lia.
    }
    destruct (tCompileSubPattern wr1 _ rer forward) as [tm1|] eqn:Htm1; simpl. 2: discriminate.
    destruct (tCompileSubPattern wr2 _ rer forward) as [tm2|] eqn:Htm2; simpl. 2: discriminate.
    specialize (IH1 tm1 eq_refl). specialize (IH2 tm2 eq_refl).
    intros tmc cont str0 Htmc_tree inp Hinp_compat ms t Hms_inp Heqt.
    simpl in Hcompsucc. injection Hcompsucc as <-.
    remember (fun s1 => tm2 s1 tmc) as tmc2.
    assert (tMC_valid tmc2 rer (Areg lr2::cont) str0) as Htmc2_tree. {
      intros inp' Hinp'_compat.
      rewrite Heqtmc2.
      unfold tm_valid, tMC_valid in IH2.
      now apply IH2 with (str0 := str0).
    }
    specialize (IH1 tmc2 (Areg lr2 :: cont) str0 Htmc2_tree inp Hinp_compat ms t Hms_inp Heqt).
    apply tree_pop_reg.
    inversion IH1.
    now apply tree_sequence.


  - (* Quantifier *)
    intros ctx Hroot Heqn. simpl. intros tm Hcompsucc.
    destruct tCompileSubPattern as [m|] eqn:Heqm; simpl. 2: discriminate.
    simpl in Hcompsucc.
    intros tmc cont str0 Htmc_valid.
    set (StaticSemantics.countLeftCapturingParensBefore _ ctx) as parenIndex in Hcompsucc.
    set (StaticSemantics.countLeftCapturingParensWithin _ _) as parenCount in Hcompsucc.
    set (Semantics.CompiledQuantifier_min _) as mini in Hcompsucc.
    set (Semantics.CompiledQuantifier_max _) as maxi in Hcompsucc.
    rewrite compilequant_greedy with (lquant := lquant) (greedy := greedy) in Hcompsucc by assumption.
    specialize (IH (Quantified_inner (wgreedylazy wquant)::ctx)).
    specialize_prove IH by eauto using same_root_down0, Down_Quantified_inner.
    specialize_prove IH. {
      unfold StaticSemantics.countLeftCapturingParensBefore in *. simpl. lia.
    }
    specialize (IH m Heqm).
    pose proof tRepeatMatcher'_valid rer greedy parenIndex parenCount mini (maxi-mini)%NoI m lr IH as Hrepeat.
    specialize_prove Hrepeat. {
      subst n. apply equiv_def_groups with (wr := wr) (ctx := ctx); auto.
    }
    destruct (mini <=? maxi)%NoI eqn:Hmini_le_maxi. 2: discriminate.
    injection Hcompsucc as <-.
    unfold tRepeatMatcher.
    intros inp Hinpcompat ms t Hmsinp Heqt.
    specialize (Hrepeat (Semantics.repeatMatcherFuel mini ms) tmc cont str0 Htmc_valid inp Hinpcompat ms t Hmsinp).
    rewrite noi_add_diff in Hrepeat by assumption. specialize (Hrepeat Heqt).
    inversion Hequivquant as [
        Heqwquant Heqlquant |
        Heqwquant Heqlquant |
        Heqwquant Heqlquant |
        nrep Heqwquant Heqlquant |
        nmin Heqwquant Heqlquant |
        mini' maxi' Hle' Heqwquant Heqlquant]; subst wquant lquant;
    inversion Hequivgreedy as [Heqwgl Heqgreedy | Heqwgl Heqgreedy]; subst wgreedylazy greedy; simpl in *; try apply Hrepeat.
    all: replace (nrep - mini) with 0 in Hrepeat by lia; apply Hrepeat.

    
  - (* Group *)
    intros ctx Hroot Heqn. simpl. intros tm Hcompsucc.
    specialize (IH (Group_inner name :: ctx)).
    specialize_prove IH by eauto using same_root_down0, Down_Group_inner.
    specialize_prove IH. {
      unfold StaticSemantics.countLeftCapturingParensBefore in *. simpl. lia.
    }
    destruct (tCompileSubPattern wr _ rer forward) as [mr|] eqn:Heqmr; simpl. 2: discriminate.
    specialize (IH mr eq_refl).
    simpl in Hcompsucc. injection Hcompsucc as <-.
    intros tmc cont str0 Htmc_tree inp Hinp_compat ms t Hms_inp Heqt.
    remember (fun y: MatchState => _) as tmc2 in Heqt.
    specialize (IH tmc2 (Aclose (S n) :: cont)).
    assert (StaticSemantics.countLeftCapturingParensBefore (Group name wr) ctx + 1 = S n) as Heqid by lia.
    assert (tMC_valid tmc2 rer (Aclose (S n) :: cont) str0) as Htmc2_tree.
    {
      intros inpend Hinpend_compat.
      subst tmc2. clear Heqt.
      unfold tMC_is_tree.
      intros msend subtree Hmsend_inp Heqsubtree.
      destruct negb eqn:Hcapvalid; simpl in *. 1: discriminate.
      rewrite Heqid in Heqsubtree. change ((S n) =? 0) with false in Heqsubtree.
      destruct (List.List.Update.Nat.One.update) as [cap|] eqn:Heqcap; simpl in *. 2: discriminate.
      specialize (Htmc_tree inpend Hinpend_compat).
      unfold tMC_is_tree in Htmc_tree.
      remember (match_state _ _ cap) as msupd. specialize (Htmc_tree msupd).
      replace (MatchState.input ms) with str0 in *.
      2: { symmetry. eapply inp_compat_ms_str0. - apply Hinp_compat. - apply Hms_inp. }
      assert (MatchState.input msend = str0) as Hmsendstr0. {
        eapply inp_compat_ms_str0. - apply Hinpend_compat. - assumption.
      }
      destruct (tmc msupd) as [subtree'|] eqn:Heqsubtree'; simpl in *. 2: discriminate.
      injection Heqsubtree as <-.
      specialize (Htmc_tree subtree').
      assert (ms_matches_inp msupd inpend) as Hmsupd_inp'. {
        subst msupd.
        eapply ms_matches_inp_capchg with (cap := MatchState.captures msend).
        rewrite <- Hmsendstr0. now destruct msend.
      }
      specialize (Htmc_tree Hmsupd_inp' eq_refl).
      apply tree_pop_close. assumption.
    }
    specialize (IH str0 Htmc2_tree inp Hinp_compat ms).
    apply tree_pop_reg.
    destruct (mr ms tmc2) as [subtree|] eqn:Heqsubtree; simpl in *. 2: discriminate.
    injection Heqt as <-.
    rewrite Heqid.
    apply tree_group.
    specialize (IH subtree Hms_inp eq_refl). inversion IH. assumption.

  - (* Lookarounds *)
    (* Let's try proving one of the two/four cases *)
    inversion Hequivlk as [Heqwlk Heqllk | Heqwlk Heqllk].
    (* Positive lookahead *)
    -- simpl. intros ctx Hroot Hparen tm.
       specialize (IH (Lookahead_inner :: ctx)).
       specialize_prove IH by eauto using same_root_down0, Down_Lookahead_inner.
       specialize_prove IH. {
         unfold StaticSemantics.countLeftCapturingParensBefore in *; simpl. lia.
       }
       destruct tCompileSubPattern as [tmsub|] eqn:Hcompilesucc; simpl. 2: discriminate.
       specialize (IH tmsub eq_refl).
       intro Heqtm. injection Heqtm as <-.
       unfold tm_valid in *. specialize (IH id_tmcont []).
       intros tmc cont str0 Htmcvalid.
       specialize (IH str0 (id_tmcont_valid rer str0)). unfold tMC_valid in *.
       intros inp Hinpcompat ms t Hmsinp.
       unfold tMC_is_tree in IH. specialize (IH inp Hinpcompat ms).
       destruct (tmsub ms _) as [tlk|] eqn:Htlk; simpl. 2: discriminate.
       specialize (IH tlk Hmsinp eq_refl).
       destruct TreeMSInterp.tree_res' as [mslk|] eqn:Hmslk; simpl.
       + (* Lookahead succeeds *)
         specialize (Htmcvalid inp Hinpcompat).
         set (msafterlk := match_state _ _ _). specialize (Htmcvalid msafterlk).
         destruct (tmc msafterlk) as [tafterlk|]; simpl. 2: discriminate.
         specialize (Htmcvalid tafterlk).
         specialize_prove Htmcvalid. { unfold msafterlk. inversion Hmsinp. now constructor. }
         specialize (Htmcvalid eq_refl).
         intro H. injection H as <-.
         apply tree_pop_reg. apply tree_lk.
         * now inversion IH.
         * unfold lk_result. simpl. unfold TreeMSInterp.first_branch'. set (msdummy := match_state _ _ _).
           destruct (TreeMSInterp.tree_res' tlk msdummy []) eqn:Heqdummy. 1: eauto.
           apply TreeMSInterp.result_indep_gm with (ms2 := ms) (gl2 := []) in Heqdummy. congruence.
         * assumption.
       + (* Lookahead fails *)
         intro H. injection H as <-.
         apply tree_pop_reg. apply tree_lk_fail.
         * now inversion IH.
         * unfold lk_result. simpl. unfold TreeMSInterp.first_branch'. set (msdummy := match_state _ _ _).
           erewrite TreeMSInterp.result_indep_gm by eauto. intros [res]; discriminate.
    -- simpl. intros ctx Hroot Hparen tm.
       specialize (IH (NegativeLookahead_inner :: ctx)).
       specialize_prove IH by eauto using same_root_down0, Down_NegativeLookahead_inner.
       specialize_prove IH. {
         unfold StaticSemantics.countLeftCapturingParensBefore in *; simpl. lia.
       }
       destruct tCompileSubPattern as [tmsub|] eqn:Hcompilesucc; simpl. 2: discriminate.
       specialize (IH tmsub eq_refl).
       intro Heqtm. injection Heqtm as <-.
       unfold tm_valid in *. specialize (IH id_tmcont []).
       intros tmc cont str0 Htmcvalid.
       specialize (IH str0 (id_tmcont_valid rer str0)). unfold tMC_valid in *.
       intros inp Hinpcompat ms t Hmsinp.
       unfold tMC_is_tree in IH. specialize (IH inp Hinpcompat ms).
       destruct (tmsub ms _) as [tlk|] eqn:Htlk; simpl. 2: discriminate.
       specialize (IH tlk Hmsinp eq_refl).
       destruct TreeMSInterp.tree_res' as [mslk|] eqn:Hmslk; simpl.
       + intro H. injection H as <-.
         apply tree_pop_reg. apply tree_lk_fail.
         1: now inversion IH.
         unfold lk_result, TreeMSInterp.first_branch'. simpl. intro H.
         apply TreeMSInterp.result_indep_gm with (ms2 := ms) (gl2 := []) in H. congruence.
       + specialize (Htmcvalid inp Hinpcompat ms).
         destruct (tmc ms) as [tnext|] eqn:Heqnext; simpl. 2: discriminate.
         intro H. injection H as <-.
         specialize (Htmcvalid tnext Hmsinp eq_refl).
         apply tree_pop_reg. apply tree_lk; auto. 1: now inversion IH.
         unfold lk_result, TreeMSInterp.first_branch'. simpl.
         eapply TreeMSInterp.result_indep_gm; eauto.
Qed.
