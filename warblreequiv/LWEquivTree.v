From Linden Require Import TMatching Tree Chars Semantics MSInput
  Regex LindenParameters RegexpTranslation ListLemmas
  WarblreLemmas Tactics LWEquivTreeLemmas LWEquivTMatcher LWEquivTMatcherLemmas NumericLemmas LKFactorization CharDescrCharSet.
From Warblre Require Import Result Notation RegExpRecord Match Base
  Patterns Node NodeProps Semantics.
From Coq Require Import List ZArith Lia.
Import Notation.
Import Result.Notations.
Import Match.MatchState.
Import ListNotations.
Import Patterns.
Import Zipper.
Import Zipper.Down.

Local Open Scope result_flow.

(** * Theorems for second part of equivalence: the trees generated by tCompileSubPattern are valid trees wrt the Linden semantics. *)


(** ** Definition of the validity of tree matchers and tree matcher continuations *)

(* `tMC_is_tree tmc rer cont inp dir` means that the TMatcherContinuation tmc, when run with a MatchState
  compatible with input inp and valid with respect to rer, performs the actions in the continuation cont and yields a valid backtree wrt direction dir. *)
Definition tMC_is_tree (tmc: TMatcherContinuation) (rer: RegExpRecord) (cont: continuation) (inp: input) (dir: Direction) :=
  forall (ms: MatchState) (t: tree),
    ms_matches_inp ms inp ->
    tmc ms = Success t ->
    is_tree Epsilon cont inp dir t.

(* `tMC_valid tmc rer cont str0 dir` means that the TMatcherContinuation tmc, when run on any input compatible with the string str0 under the flags in rer,
   performs the actions in the continuation cont and yields a valid backtree wrt direction dir. *)
Definition tMC_valid (tmc: TMatcherContinuation) (rer: RegExpRecord) (cont: continuation) (str0: string) (dir: Direction) :=
  forall inp, input_compat inp str0 -> tMC_is_tree tmc rer cont inp dir.

(* `tm_valid tm rer lreg dir` means that under the given RegExpRecord (set of flags), the TMatcher tm recognizes the regexp lreg with direction dir on any input, and yields a valid backtree. *)
Definition tm_valid (tm: TMatcher) (rer: RegExpRecord) (lreg: regex) (dir: Direction) :=
  forall (tmc: TMatcherContinuation) (cont: continuation) (str0: string),
  tMC_valid tmc rer cont str0 dir ->
  tMC_valid (fun s => tm s tmc) rer (Areg lreg::cont) str0 dir.


(* Validity of empty continuation *)
Lemma id_tmcont_valid:
  forall rer str dir, tMC_valid id_tmcont rer [] str dir.
Proof.
  intros rer str dir inp Hinp_compat ms t Hmsinp Heqt.
  injection Heqt as <-. apply tree_epsilon.
Qed.


(** ** Lemmas for repeated matching: *)
(* Lemma for the case where the min is nonzero *)
Lemma tRepeatMatcher'_minnonzero_valid:
  (* For all repeat matcher parameters (except min), *)
  forall rer greedy parenIndex parenCount plus,
  forall (tm: TMatcher) (lreg: regex) (dir: Direction),
    (* if the TMatcher tm is valid wrt lreg and direction dir, *)
    tm_valid tm rer lreg dir ->
    (* the list of capture groups of lreg matches the repeat matcher parameters, *)
    def_groups lreg = List.seq (parenIndex + 1) parenCount ->
    (* and the repeat matcher with min=0 is valid wrt Quantified greedy 0 plus lreg and direction dir, *)
    (forall fuel, tm_valid (fun s tmc => tRepeatMatcher' tm dir 0 plus greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy 0 plus lreg) dir) ->
    (* then all repeat matchers with any min are valid wrt Quantified greedy min plus lreg and direction dir. *)
    forall mini fuel, tm_valid (fun s tmc => tRepeatMatcher' tm dir mini (NoI.N mini + plus)%NoI greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy mini plus lreg) dir.
Proof.
  intros rer greedy parenIndex parenCount plus tm lreg dir Htm_valid Hgroups_valid Hminzero_valid.
  intro mini. induction mini as [|mini' IHmini'].
  1: { simpl. replace (match plus with | NoI.N r' => _ | +∞ => _ end) with plus by now destruct plus. apply Hminzero_valid. }

  intros [|fuel].
  1: { simpl. now constructor. }
  unfold tm_valid. intros tmc cont str0 Htmc_valid. unfold tMC_valid. intros inp Hinp_compat. unfold tMC_is_tree. intros ms t Hmsinp.
  simpl.
  replace (match plus with | NoI.N r' => _ | +∞ => _ end =? NoI.N (nat_to_nni 0))%NoI with false by now destruct plus.
  destruct List.List.Update.Nat.Batch.update as [cap'|] eqn:Hcapsucc; simpl. 2: discriminate.
  replace (mini' - 0) with mini' by lia.
  pose proof mini_plus_plusminus_one mini' plus as Hplusminusone. simpl in Hplusminusone. rewrite Hplusminusone. clear Hplusminusone.
  set (nextplus := match plus with | NoI.N r' => _ | +∞ => _ end).
  set (tmcnext := fun y => _).
  unfold tm_valid in Htm_valid. specialize (Htm_valid tmcnext (Areg (Regex.Quantified greedy mini' plus lreg)::cont) str0).
  specialize_prove Htm_valid. {
    specialize (IHmini' fuel tmc cont str0 Htmc_valid). simpl in IHmini'. (* Morally, apply IHmini', but there is a monad rewrite under a lambda which we cannot do... *)
    unfold tMC_valid, tMC_is_tree. intros inp' Hinp'compat ms' t' Hms'inp.
    unfold tmcnext. rewrite (@monad_id _ _ Errors.match_assertion_error). now apply IHmini'.
  }
  unfold tMC_valid in Htm_valid. specialize (Htm_valid inp Hinp_compat).
  set (msreset := match_state _ _ cap'). unfold tMC_is_tree in Htm_valid.
  specialize (Htm_valid msreset).
  destruct tm as [subtree|]; simpl. 2: discriminate.
  specialize (Htm_valid subtree). 2: reflexivity. (* ??? *)
  specialize_prove Htm_valid. { apply ms_matches_inp_capchg with (cap := MatchState.captures ms). now destruct ms. }
  specialize (Htm_valid eq_refl).
  intro Heqt. injection Heqt as <-.
  apply tree_pop_reg. apply tree_quant_minpos. 1: congruence. now inversion Htm_valid.
Qed.


(* Lemma for the case where both the min and the max are zero *)
Lemma tRepeatMatcher'_zero_valid:
  forall rer greedy parenIndex parenCount,
  forall (tm: TMatcher) (lreg: regex) (dir: Direction),
    tm_valid tm rer lreg dir ->
    def_groups lreg = List.seq (parenIndex + 1) parenCount ->
    forall fuel, tm_valid (fun s tmc => tRepeatMatcher' tm dir 0 (NoI.N 0) greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy 0 (NoI.N 0) lreg) dir.
Proof.
  intros rer greedy parenIndex parenCount tm lreg dir Htmvalid Hgroupsvalid fuel.
  destruct fuel as [|fuel]. 1: discriminate.
  simpl. unfold tm_valid, tMC_valid, tMC_is_tree. intros tmc cont str0 Htmctree inp Hinpcompat ms t Hmsinp Heqt.
  apply tree_pop_reg. apply tree_quant_minzero_pluszero. eapply Htmctree; eauto.
Qed.
  

(* Lemma for the case where the min is zero but the max is arbitrary *)
Lemma tRepeatMatcher'_minzero_valid:
  forall rer greedy parenIndex parenCount,
  forall (tm: TMatcher) (lreg: regex) (dir: Direction),
    tm_valid tm rer lreg dir ->
    def_groups lreg = List.seq (parenIndex + 1) parenCount ->
    forall fuel plus, tm_valid (fun s tmc => tRepeatMatcher' tm dir 0 plus greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy 0 plus lreg) dir.
Proof.
  intros rer greedy parenIndex parenCount tm lreg dir Htmvalid Hgroupsvalid fuel.
  induction fuel as [|fuel IHfuel].
  1: discriminate.

  intro plus.
  destruct (plus =? NoI.N (nat_to_nni 0))%NoI eqn:Hpluszero.
  1: { rewrite noi_eqb_eq in Hpluszero. subst plus. now apply tRepeatMatcher'_zero_valid. }
  simpl. rewrite Hpluszero.
  intros tmc cont str0 Htmc_valid inp Hinp_compat ms t Hms_inp HmatchSuccess.
  destruct List.List.Update.Nat.Batch.update as [cap'|] eqn:Heqcap'; simpl in *. 2: discriminate.
  set (tmcloop := fun y: MatchState => if (_ =? _)%Z then _ else _) in HmatchSuccess.
  set (msreset := match_state _ _ cap') in HmatchSuccess.
  assert (tMC_valid tmcloop rer (Acheck (ms_suffix ms dir)::Areg (Regex.Quantified greedy 0 (plus - 1)%NoI lreg)::cont) str0 dir) as Htmcloop_valid. {
    intros inp' Hinp'_compat ms1 t1 Hms1_inp Htmcloop_succeeds.
    unfold tmcloop in Htmcloop_succeeds.
    destruct (_ =? _)%Z eqn:Heqcheck.
    - (* Case 1: the input has not progressed *)
      injection Htmcloop_succeeds as <-. apply tree_pop_check_fail.
      rewrite ms_suffix_current_str with (ms := ms1) by assumption.
      unfold ms_suffix.
      rewrite Z.eqb_eq in Heqcheck.
      rewrite Heqcheck.
      replace (MatchState.input ms1) with (MatchState.input ms).
      2: {
        eapply inp_compat_ms_same_inp with (inp1 := inp) (inp2 := inp'); eauto.
      }
      reflexivity.                                               
    - (* Case 2: the input has progressed *)
      destruct tRepeatMatcher' as [subtree|] eqn:Heqsubtree; simpl in *.
      2: discriminate.
      injection Htmcloop_succeeds as <-.
      apply tree_pop_check.
      + eapply endInd_neq_advanced; eauto.
      + rewrite noi_decr in Heqsubtree. specialize (IHfuel (plus - 1)%NoI tmc cont str0 Htmc_valid inp' Hinp'_compat ms1 subtree Hms1_inp Heqsubtree). apply IHfuel.
  }
  specialize (Htmvalid tmcloop (Acheck (ms_suffix ms dir)::Areg (Regex.Quantified greedy 0 (plus-1)%NoI lreg)::cont) str0 Htmcloop_valid inp Hinp_compat).
  specialize (Htmc_valid inp Hinp_compat).
  unfold tMC_is_tree in Htmvalid, Htmc_valid.
  assert (ms_matches_inp msreset inp) as Hmsreset_inp. {
    unfold msreset. inversion Hms_inp. simpl. now constructor.
  }

  destruct greedy.
  + (* Greedy star *)
    destruct tm as [z|] eqn:Heqz; simpl. 2: discriminate.
    destruct tmc as [z'|] eqn:Heqz'; simpl. 2: discriminate.
    specialize (Htmvalid msreset z Hmsreset_inp Heqz).
    specialize (Htmc_valid ms z' Hms_inp Heqz').
    apply tree_pop_reg.
    rewrite noi_nonzero_succprec with (x := plus). 2: now apply noi_eqb_neq.
    eapply tree_quant_minzero_pluspos.
    * symmetry. apply Hgroupsvalid.
    * rewrite ms_suffix_current_str with (ms := ms). 2: assumption.
      inversion Htmvalid.
      apply TREECONT.
    * apply Htmc_valid.
    * inversion HmatchSuccess. reflexivity.

  + (* Lazy star *)
    destruct tmc as [z'|] eqn:Heqz'; simpl. 2: discriminate.
    destruct tm as [z|] eqn:Heqz; simpl. 2: discriminate.
    specialize (Htmvalid msreset z Hmsreset_inp Heqz).
    specialize (Htmc_valid ms z' Hms_inp Heqz').
    apply tree_pop_reg.
    rewrite noi_nonzero_succprec with (x := plus). 2: now apply noi_eqb_neq.
    eapply tree_quant_minzero_pluspos.
    * symmetry. apply Hgroupsvalid.
    * rewrite ms_suffix_current_str with (ms := ms). 2: assumption.
      inversion Htmvalid. apply TREECONT.
    * apply Htmc_valid.
    * inversion HmatchSuccess. reflexivity.
Qed.

(* Main theorem for repeated matching *)
Lemma tRepeatMatcher'_valid:
  (* for all repeat matcher parameters, *)
  forall rer greedy parenIndex parenCount mini plus,
    (* for any TMatcher tm that is valid with respect to some Linden regex lreg and direction dir, *)
  forall (tm: TMatcher) (lreg: regex) (dir: Direction),
    tm_valid tm rer lreg dir ->
    (* such that the defined groups of lreg correspond to the capture reset parameters of the repeat matcher, *)
    def_groups lreg = List.seq (parenIndex + 1) parenCount ->
    (* the corresponding tree repeat matcher recognizes lreg quantified accordingly to the parameters (for any fuel, provided the matcher does not run out of fuel) with direction dir. *)
    forall fuel, tm_valid (fun s tmc => tRepeatMatcher' tm dir mini (NoI.N mini + plus)%NoI greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy mini plus lreg) dir.
Proof.
  intros rer greedy parenIndex parenCount mini plus tm lreg dir Htmvalid Hgroupsvalid fuel.
  destruct mini as [|mini'].
  - replace (NoI.N 0 + plus)%NoI with plus by now destruct plus. now apply tRepeatMatcher'_minzero_valid.
  - apply tRepeatMatcher'_minnonzero_valid; auto. intro fuel0. now apply tRepeatMatcher'_minzero_valid.
Qed.


(** ** Lemma for lookarounds *)
Lemma tLookaroundMatcher_bt:
  (* lkdir: lookaround direction, pos: lookaround positivity *)
  (* lkwreg: Warblre lookaround regexp, lklreg: Linden lookaround regexp *)
  (* ctx: context of the entire lookaround regexp *)
  (* direction: direction of matching of the "parent" regexp of the lookaround *)
  (* n: number of parentheses before the lookaround regexp in the context *)
  (* wroot: the root Warblre regexp *)
  (* The hypotheses are written such that eapply then eauto works when proving the lookaround cases of the main theorem. *)
  forall lkdir pos lkwreg lklreg ctx rer direction tm n wroot
    (Hequiv: equiv_regex' lkwreg lklreg n)
    (Heqn: n = StaticSemantics.countLeftCapturingParensBefore (to_warblre_lookaround lkdir pos lkwreg) ctx)
    (Hroot: Root wroot (to_warblre_lookaround lkdir pos lkwreg, ctx))
    (IH: forall ctx, Root wroot (lkwreg, ctx) -> n = StaticSemantics.countLeftCapturingParensBefore lkwreg ctx -> forall tmlk dir, tCompileSubPattern lkwreg ctx rer dir = Success tmlk -> tm_valid tmlk rer lklreg dir)
    (Hcompilesucc: tLookaroundMatcher tCompileSubPattern lkdir pos lkwreg ctx rer direction = Success tm),
    tm_valid tm rer (Lookaround (to_lookaround lkdir pos) lklreg) direction.
Proof.
  intros.
  specialize (IH (lkCtx lkdir pos :: ctx)).
  specialize_prove IH. {
    destruct lkdir; destruct pos; simpl in *; eauto using same_root_down0, Down_Lookahead_inner, Down_Lookbehind_inner, Down_NegativeLookahead_inner, Down_NegativeLookbehind_inner.
  }
  specialize_prove IH. {
    unfold StaticSemantics.countLeftCapturingParensBefore in *.
    destruct lkdir; destruct pos; simpl in *; lia.
  }
  unfold tLookaroundMatcher in Hcompilesucc.
  destruct tCompileSubPattern as [tmlk|] eqn:Hcompilelksucc; simpl in *. 2: discriminate.
  injection Hcompilesucc as <-. specialize (IH tmlk lkdir Hcompilelksucc).
  unfold tm_valid in *. specialize (IH id_tmcont []).
  intros tmc cont str0 Htmcvalid.
  specialize (IH str0 (id_tmcont_valid rer str0 lkdir)). unfold tMC_valid in *.
  intros inp Hinpcompat ms t Hmsinp.
  unfold tMC_is_tree in IH. specialize (IH inp Hinpcompat ms).
  destruct (tmlk ms _) as [tlk|] eqn:Htlk; simpl. 2: discriminate.
  specialize (IH tlk Hmsinp eq_refl).
  destruct pos; simpl.
  - (* Positive lookaround *)
    destruct TreeMSInterp.tree_res' as [mslk|] eqn:Hmslk; simpl.
    + (* Lookaround succeeds *)
      specialize (Htmcvalid inp Hinpcompat).
      set (msafterlk := match_state _ _ _). specialize (Htmcvalid msafterlk).
      destruct (tmc msafterlk) as [tafterlk|]; simpl. 2: discriminate.
      specialize (Htmcvalid tafterlk).
      specialize_prove Htmcvalid. { unfold msafterlk. inversion Hmsinp. now constructor. }
      specialize (Htmcvalid eq_refl).
      intro H. injection H as <-.
      apply tree_pop_reg. apply tree_lk.
      * rewrite lkdir_to_lookaround. now inversion IH.
      * unfold lk_result. rewrite positivity_to_lookaround. unfold TreeMSInterp.first_branch'. set (msdummy := match_state _ _ _).
        destruct (TreeMSInterp.tree_res' tlk msdummy []) eqn:Heqdummy. 1: eauto.
        apply TreeMSInterp.result_indep_gm with (ms2 := ms) (gl2 := []) (dir2 := lkdir) in Heqdummy. congruence.
      * assumption.
    + (* Lookahead fails *)
      intro H. injection H as <-.
      apply tree_pop_reg. apply tree_lk_fail.
      * rewrite lkdir_to_lookaround. now inversion IH.
      * unfold lk_result. rewrite positivity_to_lookaround. unfold TreeMSInterp.first_branch'. set (msdummy := match_state _ _ _).
        erewrite TreeMSInterp.result_indep_gm by eauto. intros [res]; discriminate.
  - (* Negative lookaround *)
    destruct TreeMSInterp.tree_res' as [mslk|] eqn:Hmslk; simpl.
    + (* Lookaround succeeds *)
      intro H. injection H as <-.
      apply tree_pop_reg. apply tree_lk_fail.
      1: rewrite lkdir_to_lookaround; now inversion IH.
      unfold lk_result, TreeMSInterp.first_branch'. simpl. rewrite positivity_to_lookaround. intro H.
      apply TreeMSInterp.result_indep_gm with (ms2 := ms) (gl2 := []) (dir2 := lkdir) in H. congruence.
    + specialize (Htmcvalid inp Hinpcompat ms).
      destruct (tmc ms) as [tnext|] eqn:Heqnext; simpl. 2: discriminate.
      intro H. injection H as <-.
      specialize (Htmcvalid tnext Hmsinp eq_refl).
      apply tree_pop_reg. apply tree_lk; auto. 1: rewrite lkdir_to_lookaround; now inversion IH.
      unfold lk_result, TreeMSInterp.first_branch'. rewrite positivity_to_lookaround. simpl.
      eapply TreeMSInterp.result_indep_gm; eauto.
Qed.


(** ** Lemmas for character descriptors *)
Lemma exist_canonicalized_contains:
  forall rer charset chr,
  RegExpRecord.ignoreCase rer = false ->
  CharSet.exist_canonicalized rer charset (char_canonicalize rer chr) = CharSet.contains charset chr.
Proof.
  intros rer charset chr Hcasesenst.
  rewrite CharSet.exist_canonicalized_equiv. unfold Character.canonicalize. simpl.
  apply Bool.eq_true_iff_eq.
  rewrite charset_exist_iff. split.
  - intros [c [Hcontains Heq]]. do 2 rewrite canonicalize_casesenst in Heq by assumption. rewrite EqDec.inversion_true in Heq. now subst c.
  - intro Hcontains. exists chr. split. 1: assumption.
    apply EqDec.reflb.
Qed.

Lemma charSetMatcher_noninv_bt:
  forall charset cd,
  equiv_cd_charset cd charset ->
  forall rer tm dir,
  RegExpRecord.ignoreCase rer = false ->
  tm = tCharacterSetMatcher rer charset false dir ->
  tm_valid tm rer (Regex.Character cd) dir.
Proof.
  intros charset cd Hequiv rer tm dir Hcasesenst Heqtm. subst tm.
  unfold tm_valid. intros tmc cont str0 Htmcvalid.
  unfold tMC_valid. intros inp Hinpcompat. unfold tMC_is_tree. intros ms t Hmsinp.
  unfold tCharacterSetMatcher. simpl.
  set (nextend := if (dir ==? forward)%wt then _ else _).
  set (next_outofbounds := ((_ <? 0)%Z || _)%bool).
  destruct next_outofbounds eqn:Hoob; simpl.
  + intro Htm_succ. injection Htm_succ as <-.
    apply tree_pop_reg. apply tree_char_fail.
    destruct dir; simpl in *.
    * eapply read_oob_fail_end_bool; eauto. * eapply read_oob_fail_begin_bool; eauto.
  + (* If we are in bounds, then getting the character should succeed. Since we don't prove anything in the case of errors, we just assume this here *)
    destruct List.List.Indexing.Int.indexing as [chr|err] eqn:Hgetchr; simpl in *. 2: discriminate.
    rewrite exist_canonicalized_contains by assumption.
    specialize (Hequiv chr) as Hequivchr.
    pose proof next_inbounds_nextinp ms inp dir nextend Hmsinp eq_refl Hoob as Hnextinp.
    destruct Hnextinp as [inp_adv Hnextinp].
    destruct CharSet.contains; simpl in *.
    * (* Case 1: the character matches. We then want to prove that we have a read success. *)
      intro Htm_succ.
      apply tree_pop_reg.
      (* We first need to replace t with Success (Read chr child). *)
      remember (match_state _ _ _) as ms_adv in Htm_succ.
      unfold tMC_valid, tMC_is_tree in Htmcvalid.
      destruct (tmc ms_adv) as [child|] eqn:Htmc_succ; simpl in *. 2: discriminate.
      injection Htm_succ as <-.

      (* Now we apply tree_char with the next input. *)      
      apply tree_char with (nextinp := inp_adv).
      1: {
        unfold read_char.
        eapply read_char_success; eauto.
        2: { rewrite exist_canonicalized_contains by assumption. pose proof Hequiv chr as Hequivchr'. congruence. }
        destruct dir; simpl in *.
        - replace (Z.min _ _) with (MatchState.endIndex ms) in Hgetchr by lia. apply Hgetchr.
        - replace (Z.min _ _) with nextend in Hgetchr by lia. apply Hgetchr.
      }
      (* The subtree is valid: results from three lemmas. *)
      apply Htmcvalid with (ms := ms_adv).
      -- eapply advance_input_compat; eassumption.
      -- eapply ms_matches_inp_adv; eauto.
         destruct dir; unfold advance_ms; subst ms_adv; simpl in *; reflexivity.
      -- assumption.
    * (* Case 2: it is not equal. *)
      intro Htm_succ. injection Htm_succ as <-.
      apply tree_pop_reg.
      apply tree_char_fail.
      eapply read_char_fail; eauto.
      2: { rewrite exist_canonicalized_contains by assumption. pose proof Hequiv chr as Hequivchr'. rewrite Hequivchr in Hequivchr'. symmetry in Hequivchr'. eassumption. }
      destruct dir; simpl in *.
      -- replace (Z.min _ _) with (MatchState.endIndex ms) in Hgetchr by lia. auto.
      -- replace (Z.min _ _) with nextend in Hgetchr by lia. auto.
Qed.

Lemma charSetMatcher_inv_bt:
  forall charset cd,
  equiv_cd_charset cd charset ->
  forall rer tm dir,
  RegExpRecord.ignoreCase rer = false ->
  tm = tCharacterSetMatcher rer charset true dir ->
  tm_valid tm rer (Regex.Character (CdInv cd)) dir.
Proof.
  intros charset cd Hequiv rer tm dir Hcasesenst Heqtm. subst tm.
  unfold tm_valid. intros tmc cont str0 Htmcvalid.
  unfold tMC_valid. intros inp Hinpcompat. unfold tMC_is_tree. intros ms t Hmsinp.
  unfold tCharacterSetMatcher. simpl.
  set (nextend := if (dir ==? forward)%wt then _ else _).
  set (next_outofbounds := ((_ <? 0)%Z || _)%bool).
  destruct next_outofbounds eqn:Hoob; simpl.
  + intro Htm_succ. injection Htm_succ as <-.
    apply tree_pop_reg. apply tree_char_fail.
    destruct dir; simpl in *.
    * eapply read_oob_fail_end_bool; eauto. * eapply read_oob_fail_begin_bool; eauto.
  + (* If we are in bounds, then getting the character should succeed. Since we don't prove anything in the case of errors, we just assume this here *)
    destruct List.List.Indexing.Int.indexing as [chr|err] eqn:Hgetchr; simpl in *. 2: discriminate.
    rewrite exist_canonicalized_contains by assumption.
    specialize (Hequiv chr) as Hequivchr.
    pose proof next_inbounds_nextinp ms inp dir nextend Hmsinp eq_refl Hoob as Hnextinp.
    destruct Hnextinp as [inp_adv Hnextinp].
    destruct CharSet.contains; simpl in *.
    * (* Case 1: the character matches. *)
      intro Htm_succ. injection Htm_succ as <-.
      apply tree_pop_reg.
      apply tree_char_fail.
      eapply read_char_success; eauto.
      2: { rewrite exist_canonicalized_contains by assumption. pose proof Hequiv chr as Hequivchr'. rewrite Hequivchr in Hequivchr'. symmetry in Hequivchr'. eassumption. }
      destruct dir; simpl in *.
      -- replace (Z.min _ _) with (MatchState.endIndex ms) in Hgetchr by lia. auto.
      -- replace (Z.min _ _) with nextend in Hgetchr by lia. auto.
    * (* Case 2: the character doesn't match. We then want to prove that we have a read success. *)
      intro Htm_succ.
      apply tree_pop_reg.
      (* We first need to replace t with Success (Read chr child). *)
      remember (match_state _ _ _) as ms_adv in Htm_succ.
      unfold tMC_valid, tMC_is_tree in Htmcvalid.
      destruct (tmc ms_adv) as [child|] eqn:Htmc_succ; simpl in *. 2: discriminate.
      injection Htm_succ as <-.

      (* Now we apply tree_char with the next input. *)
      apply tree_char with (nextinp := inp_adv).
      1: {
        unfold read_char.
        eapply read_char_fail; eauto.
        2: { rewrite exist_canonicalized_contains by assumption. pose proof Hequiv chr as Hequivchr'. congruence. }
        destruct dir; simpl in *.
        - replace (Z.min _ _) with (MatchState.endIndex ms) in Hgetchr by lia. apply Hgetchr.
        - replace (Z.min _ _) with nextend in Hgetchr by lia. apply Hgetchr.
      }
      (* The subtree is valid: results from three lemmas. *)
      apply Htmcvalid with (ms := ms_adv).
      -- eapply advance_input_compat; eassumption.
      -- eapply ms_matches_inp_adv; eauto.
         destruct dir; unfold advance_ms; subst ms_adv; simpl in *; reflexivity.
      -- assumption.
Qed.

(* Lemma for character class escapes *)
Lemma characterclassescape_bt:
  forall (rer: RegExpRecord) (lroot: regex) (wroot: Regex)
    (root_equiv: equiv_regex wroot lroot),
    RegExpRecord.ignoreCase rer = false ->
  forall esc wreg lreg ctx,
    wreg = AtomEsc (ACharacterClassEsc esc) ->
    Root wroot (wreg, ctx) ->
    equiv_regex' wreg lreg (StaticSemantics.countLeftCapturingParensBefore wreg ctx) ->
    forall tm dir,
      tCompileSubPattern wreg ctx rer dir = Success tm ->
      tm_valid tm rer lreg dir.
Proof.
  intros rer lroot wroot root_equiv Hcasesenst esc wreg lreg ctx Heqwreg Hroot Hequiv tm dir.
  subst wreg. inversion Hequiv as [| | | esc0 cd n Hequiv' Heqesc0 Heqlreg Heqn | | | | | | | |].
  2: { (* Absurd *) inversion H0; inversion H2; subst; discriminate. }
  2: { (* Absurd *) inversion H; discriminate. }
  subst lreg esc0 n. simpl.
  inversion Hequiv' as [Heqesc Heqcd | Heqesc Heqcd | Heqesc Heqcd | Heqesc Heqcd | Heqesc Heqcd | Heqesc Heqcd]; simpl in *; intro H; injection H as H; eapply charSetMatcher_noninv_bt; eauto; rewrite charset_union_empty.
  - apply equiv_cd_digits.
  - apply equiv_cd_inv. apply equiv_cd_digits.
  - apply equiv_cd_whitespace.
  - apply equiv_cd_inv. apply equiv_cd_whitespace.
  - pose proof wordCharacters_casesenst rer Hcasesenst. unfold Semantics.wordCharacters, Coercions.wrap_CharSet in H0. simpl in H0. injection H0 as H0. rewrite H0. apply equiv_cd_wordchar.
  - apply equiv_cd_inv. pose proof wordCharacters_casesenst rer Hcasesenst. unfold Semantics.wordCharacters, Coercions.wrap_CharSet in H0. simpl in H0. injection H0 as H0. rewrite H0. apply equiv_cd_wordchar.
Qed.

(** ** Main theorem *)
(* We place ourselves in the context of some root regex, and prove the validity for all the sub-regexes of the root regex. *)
Theorem tmatcher_bt:
  forall (rer: RegExpRecord) (lroot: regex) (wroot: Regex)
    (* Assume that we do not ignore case, *)
    (Hcasesenst: RegExpRecord.ignoreCase rer = false)
    (* that we do not consider line ends and starts to be input ends and starts, respectively, *)
    (Hnomultiline: RegExpRecord.multiline rer = false)
    (* and that dot matches all characters. *)
    (Hdotall: RegExpRecord.dotAll rer = true)
    (* Let lroot and wroot be a pair of equivanent regexes. *)
    (root_equiv: equiv_regex wroot lroot),
    (* Then for any sub-regex wreg of the root Warblre regex, *)
  forall (wreg: Regex) (lreg: regex) ctx,
    Root wroot (wreg, ctx) ->
    (* and any Linden regex lreg that is equivalent to this sub-regex with the right number of left capturing parentheses before, *)
    equiv_regex' wreg lreg (StaticSemantics.countLeftCapturingParensBefore wreg ctx) ->
    forall tm dir,
      (* if tCompileSubPattern with direction dir yields a TMatcher for regex wreg, *)
      tCompileSubPattern wreg ctx rer dir = Success tm ->
      (* then this TMatcher is valid with respect to the regex lreg and direction dir. *)
      tm_valid tm rer lreg dir.
Proof.
  intros rer lroot wroot Hcasesenst Hnomultiline Hdotall root_equiv wreg lreg ctx Hroot Hequiv.
  remember (StaticSemantics.countLeftCapturingParensBefore _ _) as n in Hequiv.
  revert ctx Hroot Heqn.
  induction Hequiv as [
      n |
      n c |
      n |
      esc cd n Hequivesc |
      esc cd n Hequivesc |
      cc cd n Hequivcc |
      n wr1 wr2 lr1 lr2 Hequiv1 IH1 Hequiv2 IH2 |
      n wr1 wr2 lr1 lr2 Hequiv1 IH1 Hequiv2 IH2 |
      n wr lr wquant lquant wgreedylazy greedy Hequiv IH Hequivquant Hequivgreedy |
      name n wr lr Hequiv IH |
      n wr lr wlk llk Hequiv IH Hequivlk |
      n wr lanchor Hanchequiv
  ].


  - (* Empty *)
    simpl. intros _ _ _.
    intros tm dir Hcompsucc tmc cont str0 Htmc_tree inp Hinp_compat.
    injection Hcompsucc as <-.
    intros ms t Hms_inp Htmc_succ.
    apply tree_pop_reg. unfold tMC_valid, tMC_is_tree in Htmc_tree.
    now apply Htmc_tree with (ms := ms).


  - (* Character *)
    simpl. intros ctx Hroot _ tm dir Hcompile_succ tmc cont str0 Htmc_tree inp Hinp_compat ms t Hms_inp Htm_succ.
    injection Hcompile_succ as Hcompile_succ. symmetry in Hcompile_succ.
    eapply charSetMatcher_noninv_bt; eauto. apply equiv_cd_single.

  (* Dot *)
  - simpl. intros ctx Hroot _ tm dir Hcompile_succ tmc cont str0 Htmc_tree inp Hinp_compat ms t Hms_inp Htm_succ.
    injection Hcompile_succ as Hcompile_succ. symmetry in Hcompile_succ.
    eapply charSetMatcher_noninv_bt; eauto. rewrite Hdotall. apply equiv_cd_dot.


  (* AtomEsc (ACharacterClassEsc esc) *)
  - intros ctx Hroot Heqn tm dir. eapply characterclassescape_bt; eauto.
    constructor. assumption.

  (* AtomEsc (ACharacterEsc esc) *)
  - admit.

  (* Character class *)
  - admit.


  - (* Disjunction *)
    intros ctx Hroot Heqn.
    simpl in *.
    specialize (IH1 (Disjunction_left wr2 :: ctx)).
    specialize (IH2 (Disjunction_right wr1 :: ctx)).
    specialize_prove IH1 by eauto using same_root_down0, Down_Disjunction_left.
    specialize_prove IH1. {
      simpl. unfold StaticSemantics.countLeftCapturingParensBefore in *. lia.
    }
    specialize_prove IH2 by eauto using same_root_down0, Down_Disjunction_right.
    specialize_prove IH2. {
      unfold StaticSemantics.countLeftCapturingParensBefore in *. simpl.
      assert (num_groups lr1 = StaticSemantics.countLeftCapturingParensWithin_impl wr1) by (eapply num_groups_equiv; eassumption).
      lia.
    }
    intros tm dir Hcompsucc.
    destruct (tCompileSubPattern wr1 _ rer dir) as [tm1|] eqn:Htm1; simpl. 2: discriminate.
    destruct (tCompileSubPattern wr2 _ rer dir) as [tm2|] eqn:Htm2; simpl. 2: discriminate.
    simpl in Hcompsucc. injection Hcompsucc as <-.
    intros tmc cont str0 Htmc_tree inp Hinp_compat s t Hs_inp Heqt.
    specialize (IH1 tm1 dir Htm1 tmc cont str0 Htmc_tree inp Hinp_compat).
    specialize (IH2 tm2 dir Htm2 tmc cont str0 Htmc_tree inp Hinp_compat).
    destruct (tm1 s tmc) as [t1|] eqn:Heqt1; simpl. 2: discriminate.
    destruct (tm2 s tmc) as [t2|] eqn:Heqt2; simpl. 2: discriminate.
    specialize (IH1 s t1 Hs_inp). specialize (IH2 s t2 Hs_inp).
    simpl in *.
    rewrite Heqt1 in IH1. rewrite Heqt2 in IH2.
    apply tree_pop_reg.
    injection Heqt as <-.
    specialize (IH1 eq_refl). specialize (IH2 eq_refl).
    inversion IH1. inversion IH2.
    now apply tree_disj.


  - (* Sequence *)
    intros ctx Hroot Heqn. simpl in *. intros tm dir Hcompsucc.
    specialize (IH1 (Seq_left wr2 :: ctx)).
    specialize (IH2 (Seq_right wr1 :: ctx)).
    specialize_prove IH1 by eauto using same_root_down0, Down_Seq_left.
    specialize_prove IH1. {
      unfold StaticSemantics.countLeftCapturingParensBefore in *.
      simpl.
      lia.
    }
    specialize_prove IH2 by eauto using same_root_down0, Down_Seq_right.
    specialize_prove IH2. {
      unfold StaticSemantics.countLeftCapturingParensBefore in *.
      simpl.
      assert (H: num_groups lr1 = StaticSemantics.countLeftCapturingParensWithin_impl wr1) by (eapply num_groups_equiv; eassumption).
      lia.
    }
    destruct (tCompileSubPattern wr1 _ rer dir) as [tm1|] eqn:Htm1; simpl. 2: discriminate.
    destruct (tCompileSubPattern wr2 _ rer dir) as [tm2|] eqn:Htm2; simpl. 2: discriminate.
    specialize (IH1 tm1 dir Htm1). specialize (IH2 tm2 dir Htm2).
    intros tmc cont str0 Htmc_tree inp Hinp_compat ms t Hms_inp Heqt.
    simpl in Hcompsucc. destruct dir; injection Hcompsucc as <-.
    + remember (fun s1 => tm2 s1 tmc) as tmc2.
      assert (tMC_valid tmc2 rer (Areg lr2::cont) str0 forward) as Htmc2_tree. {
        intros inp' Hinp'_compat.
        rewrite Heqtmc2.
        unfold tm_valid, tMC_valid in IH2.
        now apply IH2 with (str0 := str0).
      }
      specialize (IH1 tmc2 (Areg lr2 :: cont) str0 Htmc2_tree inp Hinp_compat ms t Hms_inp Heqt).
      apply tree_pop_reg.
      inversion IH1.
      now apply tree_sequence_fwd.
    + remember (fun s2 => tm1 s2 tmc) as tmc1.
      assert (tMC_valid tmc1 rer (Areg lr1::cont) str0 backward) as Htmc1_tree. {
        intros inp' Hinp'_compat.
        rewrite Heqtmc1.
        unfold tm_valid, tMC_valid in IH1.
        now apply IH1 with (str0 := str0).
      }
      specialize (IH2 tmc1 (Areg lr1::cont) str0 Htmc1_tree inp Hinp_compat ms t Hms_inp Heqt).
      apply tree_pop_reg.
      inversion IH2.
      now apply tree_sequence_bwd.


  - (* Quantifier *)
    intros ctx Hroot Heqn. simpl. intros tm dir Hcompsucc.
    destruct tCompileSubPattern as [m|] eqn:Heqm; simpl. 2: discriminate.
    simpl in Hcompsucc.
    intros tmc cont str0 Htmc_valid.
    set (StaticSemantics.countLeftCapturingParensBefore _ ctx) as parenIndex in Hcompsucc.
    set (StaticSemantics.countLeftCapturingParensWithin _ _) as parenCount in Hcompsucc.
    set (Semantics.CompiledQuantifier_min _) as mini in Hcompsucc.
    set (Semantics.CompiledQuantifier_max _) as maxi in Hcompsucc.
    rewrite compilequant_greedy with (lquant := lquant) (greedy := greedy) in Hcompsucc by assumption.
    specialize (IH (Quantified_inner (wgreedylazy wquant)::ctx)).
    specialize_prove IH by eauto using same_root_down0, Down_Quantified_inner.
    specialize_prove IH. {
      unfold StaticSemantics.countLeftCapturingParensBefore in *. simpl. lia.
    }
    specialize (IH m dir Heqm).
    pose proof tRepeatMatcher'_valid rer greedy parenIndex parenCount mini (maxi-mini)%NoI m lr dir IH as Hrepeat.
    specialize_prove Hrepeat. {
      subst n. apply equiv_def_groups with (wr := wr) (ctx := ctx); auto.
    }
    destruct (mini <=? maxi)%NoI eqn:Hmini_le_maxi. 2: discriminate.
    injection Hcompsucc as <-.
    unfold tRepeatMatcher.
    intros inp Hinpcompat ms t Hmsinp Heqt.
    specialize (Hrepeat (Semantics.repeatMatcherFuel mini ms) tmc cont str0 Htmc_valid inp Hinpcompat ms t Hmsinp).
    rewrite noi_add_diff in Hrepeat by assumption. specialize (Hrepeat Heqt).
    inversion Hequivquant as [
        Heqwquant Heqlquant |
        Heqwquant Heqlquant |
        Heqwquant Heqlquant |
        nrep Heqwquant Heqlquant |
        nmin Heqwquant Heqlquant |
        mini' maxi' Hle' Heqwquant Heqlquant]; subst wquant lquant;
    inversion Hequivgreedy as [Heqwgl Heqgreedy | Heqwgl Heqgreedy]; subst wgreedylazy greedy; simpl in *; try apply Hrepeat.
    all: replace (nrep - mini) with 0 in Hrepeat by lia; apply Hrepeat.

    
  - (* Group *)
    intros ctx Hroot Heqn. simpl. intros tm dir Hcompsucc.
    specialize (IH (Group_inner name :: ctx)).
    specialize_prove IH by eauto using same_root_down0, Down_Group_inner.
    specialize_prove IH. {
      unfold StaticSemantics.countLeftCapturingParensBefore in *. simpl. lia.
    }
    destruct (tCompileSubPattern wr _ rer dir) as [mr|] eqn:Heqmr; simpl. 2: discriminate.
    specialize (IH mr dir Heqmr).
    simpl in Hcompsucc. injection Hcompsucc as <-.
    intros tmc cont str0 Htmc_tree inp Hinp_compat ms t Hms_inp Heqt.
    remember (fun y: MatchState => _) as tmc2 in Heqt.
    specialize (IH tmc2 (Aclose (S n) :: cont)).
    assert (StaticSemantics.countLeftCapturingParensBefore (Group name wr) ctx + 1 = S n) as Heqid by lia.
    assert (tMC_valid tmc2 rer (Aclose (S n) :: cont) str0 dir) as Htmc2_tree.
    {
      intros inpend Hinpend_compat.
      subst tmc2. clear Heqt.
      unfold tMC_is_tree.
      intros msend subtree Hmsend_inp Heqsubtree.
      remember (if (dir ==? forward)%wt then _ else _) as rres. destruct rres as [r|] eqn:Hrres; simpl in *. 2: discriminate.
      rewrite Heqid in Heqsubtree. change ((S n) =? 0) with false in Heqsubtree.
      destruct (List.List.Update.Nat.One.update) as [cap|] eqn:Heqcap; simpl in *. 2: discriminate.
      specialize (Htmc_tree inpend Hinpend_compat).
      unfold tMC_is_tree in Htmc_tree.
      remember (match_state _ _ cap) as msupd. specialize (Htmc_tree msupd).
      replace (MatchState.input ms) with str0 in *.
      2: { symmetry. eapply inp_compat_ms_str0. - apply Hinp_compat. - apply Hms_inp. }
      assert (MatchState.input msend = str0) as Hmsendstr0. {
        eapply inp_compat_ms_str0. - apply Hinpend_compat. - assumption.
      }
      destruct (tmc msupd) as [subtree'|] eqn:Heqsubtree'; simpl in *. 2: discriminate.
      injection Heqsubtree as <-.
      specialize (Htmc_tree subtree').
      assert (ms_matches_inp msupd inpend) as Hmsupd_inp'. {
        subst msupd.
        eapply ms_matches_inp_capchg with (cap := MatchState.captures msend).
        rewrite <- Hmsendstr0. now destruct msend.
      }
      specialize (Htmc_tree Hmsupd_inp' eq_refl).
      apply tree_pop_close. assumption.
    }
    specialize (IH str0 Htmc2_tree inp Hinp_compat ms).
    apply tree_pop_reg.
    destruct (mr ms tmc2) as [subtree|] eqn:Heqsubtree; simpl in *. 2: discriminate.
    injection Heqt as <-.
    rewrite Heqid.
    apply tree_group.
    specialize (IH subtree Hms_inp eq_refl). inversion IH. assumption.

  - (* Lookarounds *)
    (* We use the lemma tLookaroundMatcher_bt *)
    inversion Hequivlk as [Heqwlk Heqllk | Heqwlk Heqllk | Heqwlk Heqllk | Heqwlk Heqllk]; simpl; intros.
    + eapply tLookaroundMatcher_bt with (lkdir := forward) (pos := true); eauto.
    + eapply tLookaroundMatcher_bt with (lkdir := forward) (pos := false); eauto.
    + eapply tLookaroundMatcher_bt with (lkdir := backward) (pos := true); eauto.
    + eapply tLookaroundMatcher_bt with (lkdir := backward) (pos := false); eauto.

  - (* Anchors *)
    inversion Hanchequiv as [Heqwr Heqlanchor | Heqwr Heqlanchor | Heqwr Heqlanchor | Heqwr Heqlanchor]; simpl.
    
    + (* Input start *)
      intros ctx Hroot Heqn tm dir Heqtm. injection Heqtm as <-.
      unfold tm_valid. intros tmc cont str0 Htmcvalid inp Hinpcompat ms t Hmsinp.
      rewrite Hnomultiline. simpl.
      destruct (MatchState.endIndex ms =? 0)%Z eqn:Hatbegin; simpl.
      * rewrite Z.eqb_eq in Hatbegin. unfold tMC_valid in Htmcvalid. specialize (Htmcvalid inp Hinpcompat ms).
        destruct (tmc ms) as [subtree|]; simpl in *. 2: discriminate.
        specialize (Htmcvalid subtree Hmsinp eq_refl).
        intro H. injection H as <-.
        apply tree_pop_reg. apply tree_anchor. 2: assumption.
        unfold anchor_satisfied.
        pose proof begin_input_pref_empty _ _ Hatbegin Hmsinp as Hprefnil. now destruct Hprefnil as [next ->].
      * intro H. injection H as <-.
        apply tree_pop_reg. apply tree_anchor_fail. unfold anchor_satisfied.
        rewrite Z.eqb_neq in Hatbegin.
        pose proof begin_input_pref_nonempty _ _ Hatbegin Hmsinp as Hprefnotnil. now destruct Hprefnotnil as [next [x [pref ->]]].
        
    + (* Input end *)
      intros ctx Hroot Heqn tm dir Heqtm. injection Heqtm as <-.
      unfold tm_valid. intros tmc cont str0 Htmcvalid inp Hinpcompat ms t Hmsinp.
      rewrite Hnomultiline. simpl.
      destruct (MatchState.endIndex ms =? _)%Z eqn:Hatend; simpl.
      * rewrite Z.eqb_eq in Hatend. specialize (Htmcvalid inp Hinpcompat ms).
        destruct (tmc ms) as [subtree|]; simpl in *. 2: discriminate.
        specialize (Htmcvalid subtree Hmsinp eq_refl).
        intro H. injection H as <-.
        apply tree_pop_reg. apply tree_anchor. 2: assumption.
        unfold anchor_satisfied.
        pose proof end_input_next_empty _ _ Hatend Hmsinp as Hnextnil. now destruct Hnextnil as [pref ->].
      * rewrite Z.eqb_neq in Hatend.
        intro H. injection H as <-.
        apply tree_pop_reg. apply tree_anchor_fail. unfold anchor_satisfied.
        pose proof end_input_next_nonempty _ _ Hatend Hmsinp as Hnextnotnil. now destruct Hnextnotnil as [pref [x [next ->]]].

    + (* Word boundary *)
      intros ctx Hroot Heqn tm dir Heqtm. injection Heqtm as <-.
      unfold tm_valid. intros tmc cont str0 Htmcvalid.
      unfold tMC_valid. intros inp Hinpcompat ms t Hmsinp Heqt.
      destruct Semantics.isWordChar as [a|] eqn:Hwca; simpl in *. 2: discriminate.
      destruct (Semantics.isWordChar rer (_ ms) (MatchState.endIndex ms)) as [b|] eqn:Hwcb; simpl in *. 2: discriminate.
      rewrite ifthenelse_xorb in Heqt. pose proof is_boundary_xorb _ _ _ _ _ Hcasesenst Hmsinp Hwca Hwcb as Hisboundary.
      destruct xorb.
      * (* We are on a boundary *)
        unfold tMC_valid in Htmcvalid. specialize (Htmcvalid inp Hinpcompat ms).
        destruct (tmc ms) as [subtree|] eqn:Hsubtree; simpl in *. 2: discriminate.
        specialize (Htmcvalid subtree Hmsinp eq_refl). injection Heqt as <-.
        apply tree_pop_reg. apply tree_anchor. 2: assumption. unfold anchor_satisfied.
        destruct inp as [next pref]. congruence.
      * (* We are not *)
        apply tree_pop_reg. injection Heqt as <-. apply tree_anchor_fail.
        unfold anchor_satisfied. destruct inp as [next pref]; congruence.
      
    + (* Non word boundary *)
      intros ctx Hroot Heqn tm dir Heqtm. injection Heqtm as <-.
      intros tmc cont str0 Htmcvalid inp Hinpcompat ms t Hmsinp Heqt.
      destruct Semantics.isWordChar as [a|] eqn:Hwca; simpl in *. 2: discriminate.
      destruct (Semantics.isWordChar rer (_ ms) (MatchState.endIndex ms)) as [b|] eqn:Hwcb; simpl in *. 2: discriminate.
      rewrite ifthenelse_negb_xorb in Heqt. pose proof is_boundary_xorb _ _ _ _ _ Hcasesenst Hmsinp Hwca Hwcb as Hisboundary.
      destruct xorb.
      * (* We are on a boundary *)
        simpl in Heqt. injection Heqt as <-.
        apply tree_pop_reg. apply tree_anchor_fail. unfold anchor_satisfied. destruct inp as [next pref].
        rewrite <- Hisboundary. reflexivity.
      * (* We are not *)
        specialize (Htmcvalid inp Hinpcompat ms).
        destruct (tmc ms) as [subtree|] eqn:Hsubtree; simpl in *. 2: discriminate.
        specialize (Htmcvalid subtree Hmsinp eq_refl). injection Heqt as <-.
        apply tree_pop_reg. apply tree_anchor. 2: assumption. unfold anchor_satisfied.
        destruct inp as [next pref]. rewrite <- Hisboundary. reflexivity.
Admitted.
