From Linden Require Import TMatching Tree Chars Semantics MSInput
  Regex LindenParameters RegexpTranslation ListLemmas Groups
  WarblreLemmas Tactics LWEquivTreeLemmas LWEquivTMatcher LWEquivTMatcherLemmas
  NumericLemmas LKFactorization CharDescrCharSet CharSet GroupMapMS.
From Warblre Require Import Result Notation RegExpRecord Match Base
  Patterns Node NodeProps Semantics.
From Coq Require Import List ZArith Lia.
Import Notation.
Import Result.Notations.
Import Match.MatchState.
Import ListNotations.
Import Patterns.
Import Zipper.
Import Zipper.Down.

Local Open Scope result_flow.

(** * Theorems for second part of equivalence: the trees generated by tCompileSubPattern are valid trees wrt the Linden semantics. *)


Section LWEquivTree.
  Context `{characterClass: Character.class}.

  (** ** Definition of the validity of tree matchers and tree matcher continuations *)

  (* `tMC_is_tree tmc gl rer actions inp dir` means that the TMatcherContinuation tmc
    closes the groups defined in gl and, when run with a MatchState
    compatible with input inp and valid with respect to rer, performs the actions in the
    list actions and yields a valid priority tree wrt direction dir and the group map
    corresponding to the MatchState and the list of open groups. *)
  Definition tMC_is_tree (tmc: TMatcherContinuation) (gl: open_groups) (rer: RegExpRecord) (actions: actions) (inp: input) (dir: Direction) :=
    forall (ms: MatchState) (gm: GroupMap.t) (t: tree),
      ms_matches_inp ms inp ->
      tmc ms = Success t ->
      equiv_groupmap_ms gm ms ->
      group_map_equiv_open_groups gm gl ->
      is_tree actions inp gm dir t.

  (* `tMC_valid tmc gl rer actions str0 dir` means that the TMatcherContinuation tmc closes
    the groups defined in gl and, when run on any input compatible with the string str0 under
    the flags in rer, performs the actions in the list actions and yields a valid priority
    tree wrt direction dir. *)
  Definition tMC_valid (tmc: TMatcherContinuation) (gl: open_groups) (rer: RegExpRecord) (actions: actions) (str0: string) (dir: Direction) :=
    forall inp, input_compat inp str0 -> tMC_is_tree tmc gl rer actions inp dir.

  (* `tm_valid tm rer lreg dir` means that under the given RegExpRecord (set of flags), the TMatcher tm recognizes the regexp lreg with direction dir on any input, and yields a valid priority tree. *)
  Definition tm_valid (tm: TMatcher) (rer: RegExpRecord) (lreg: regex) (dir: Direction) :=
    forall (tmc: TMatcherContinuation) (gl: open_groups) (actions: actions) (str0: string),
    open_groups_disjoint gl (def_groups lreg) ->
    tMC_valid tmc gl rer actions str0 dir ->
    tMC_valid (fun s => tm s tmc) gl rer (Areg lreg::actions) str0 dir.


  (* Validity of empty continuation, which does not close any group and does not perform any action *)
  Lemma id_tmcont_valid:
    forall rer str dir, tMC_valid id_tmcont [] rer [] str dir.
  Proof.
    intros rer str dir inp Hinp_compat ms gm t Hmsinp Heqt Hgmms Hgmgl.
    injection Heqt as <-. apply tree_epsilon.
  Qed.


  (** ** Lemmas for repeated matching: *)
  (* Lemma for the case where the min is nonzero *)
  Lemma tRepeatMatcher'_forced_valid:
    (* For all repeat matcher parameters (except min), *)
    forall rer greedy parenIndex parenCount delta,
    forall (tm: TMatcher) (lreg: regex) (dir: Direction),
      (* if the TMatcher tm is valid wrt lreg and direction dir, *)
      tm_valid tm rer lreg dir ->
      (* the list of capture groups of lreg matches the repeat matcher parameters, *)
      def_groups lreg = List.seq (parenIndex + 1) parenCount ->
      (* and the repeat matcher with min=0 is valid wrt Quantified greedy 0 delta lreg and direction dir, *)
      (forall fuel, tm_valid (fun s tmc => tRepeatMatcher' tm dir 0 delta greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy 0 delta lreg) dir) ->
      (* then all repeat matchers with any min are valid wrt Quantified greedy min delta lreg and direction dir. *)
      forall mini fuel, tm_valid (fun s tmc => tRepeatMatcher' tm dir mini (NoI.N mini + delta)%NoI greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy mini delta lreg) dir.
  Proof.
    intros rer greedy parenIndex parenCount delta tm lreg dir Htm_valid Hgroups_valid Hminzero_valid.
    intro mini. induction mini as [|mini' IHmini'].
    1: { simpl. replace (match delta with | NoI.N r' => _ | +∞ => _ end) with delta by now destruct delta. apply Hminzero_valid. }

    intros [|fuel].
    1: { simpl. unfold tm_valid. intros. unfold tMC_valid. intros. unfold tMC_is_tree. discriminate. }
    unfold tm_valid. intros tmc gl actions str0 Hgldisj Htmc_valid. unfold tMC_valid. intros inp Hinp_compat. unfold tMC_is_tree. intros ms gm t Hmsinp.
    simpl.
    replace (match delta with | NoI.N r' => _ | +∞ => _ end =? NoI.N (nat_to_nni 0))%NoI with false by now destruct delta.
    destruct List.List.Update.Nat.Batch.update as [cap'|] eqn:Hcapsucc; simpl. 2: discriminate.
    replace (mini' - 0) with mini' by lia.
    pose proof mini_plus_plusminus_one mini' delta as Hplusminusone. simpl in Hplusminusone. rewrite Hplusminusone by reflexivity. (* ??? *) clear Hplusminusone.
    set (nextdelta := match delta with | NoI.N r' => _ | +∞ => _ end).
    set (tmcnext := fun y => _).
    unfold tm_valid in Htm_valid. specialize (Htm_valid tmcnext gl (Areg (Regex.Quantified greedy mini' delta lreg)::actions) str0).
    specialize_prove Htm_valid by admit. (* Disjointness from quantifier implies disjointness from sub-regexp *)
    specialize_prove Htm_valid. {
      specialize (IHmini' fuel tmc gl actions str0 Hgldisj Htmc_valid). simpl in IHmini'. (* Morally, apply IHmini', but there is a monad rewrite under a lambda which we cannot do... *)
      unfold tMC_valid, tMC_is_tree. intros inp' Hinp'compat ms' t' Hms'inp.
      unfold tmcnext. rewrite (@monad_id _ _ Errors.match_assertion_error). now apply IHmini'.
    }
    unfold tMC_valid in Htm_valid. specialize (Htm_valid inp Hinp_compat).
    set (msreset := match_state _ _ cap'). unfold tMC_is_tree in Htm_valid.
    specialize (Htm_valid msreset (GroupMap.reset (seq (parenIndex+1) parenCount) gm)).
    destruct tm as [subtree|]; simpl. 2: discriminate.
    specialize (Htm_valid subtree).
    specialize_prove Htm_valid. { apply ms_matches_inp_capchg with (cap := MatchState.captures ms). now destruct ms. }
    specialize (Htm_valid eq_refl).
    specialize_prove Htm_valid by admit.
    specialize_prove Htm_valid by admit.

    intro Heqt. injection Heqt as <-. intros Hgmms Hgmgl.
    apply tree_quant_forced. 1: congruence. assumption.
  Admitted.


  (* Lemma for the case where both the min and the max are zero *)
  Lemma tRepeatMatcher'_done_valid:
    forall rer greedy parenIndex parenCount,
    forall (tm: TMatcher) (lreg: regex) (dir: Direction),
      tm_valid tm rer lreg dir ->
      def_groups lreg = List.seq (parenIndex + 1) parenCount ->
      forall fuel, tm_valid (fun s tmc => tRepeatMatcher' tm dir 0 (NoI.N 0) greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy 0 (NoI.N 0) lreg) dir.
  Proof.
    intros rer greedy parenIndex parenCount tm lreg dir Htmvalid Hgroupsvalid fuel.
    destruct fuel as [|fuel]. 1: discriminate.
    simpl. unfold tm_valid, tMC_valid, tMC_is_tree. intros tmc gl actions str0 Hgldisj Htmctree inp Hinpcompat ms gm t Hmsinp Heqt Hgmms Hgmgl.
    apply tree_quant_done. eapply Htmctree; eauto.
  Qed.


  (* Lemma for the case where the min is zero but the max is arbitrary *)
  Lemma tRepeatMatcher'_free_valid:
    forall rer greedy parenIndex parenCount,
    forall (tm: TMatcher) (lreg: regex) (dir: Direction),
      tm_valid tm rer lreg dir ->
      def_groups lreg = List.seq (parenIndex + 1) parenCount ->
      forall fuel delta, tm_valid (fun s tmc => tRepeatMatcher' tm dir 0 delta greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy 0 delta lreg) dir.
  Proof.
    intros rer greedy parenIndex parenCount tm lreg dir Htmvalid Hgroupsvalid fuel.
    induction fuel as [|fuel IHfuel].
    1: discriminate.

    intro delta.
    destruct (delta =? NoI.N (nat_to_nni 0))%NoI eqn:Hdeltazero.
    1: { rewrite noi_eqb_eq in Hdeltazero. subst delta. now apply tRepeatMatcher'_done_valid. }
    simpl. rewrite Hdeltazero.
    unfold tm_valid.
    intros tmc gl actions str0 Hgldisj Htmc_valid inp Hinp_compat.
    unfold tMC_is_tree. intros ms gm t Hmsinp HmatchSuccess Hgmms Hgmgl.
    destruct List.List.Update.Nat.Batch.update as [cap'|] eqn:Heqcap'; simpl in *. 2: discriminate.
    set (tmcloop := fun y: MatchState => if (_ =? _)%Z then _ else _) in HmatchSuccess.
    set (msreset := match_state _ _ cap') in HmatchSuccess.
    assert (tMC_valid tmcloop gl rer (Acheck (ms_suffix ms dir)::Areg (Regex.Quantified greedy 0 (delta - 1)%NoI lreg)::actions) str0 dir) as Htmcloop_valid. {
      unfold tMC_valid. intros inp' Hinp'_compat.
      unfold tMC_is_tree. intros ms1 gm1 t1 Hms1inp Htmcloop_succeeds Hgm1ms1 Hgm1gl.
      unfold tmcloop in Htmcloop_succeeds.
      destruct (_ =? _)%Z eqn:Heqcheck.
      - (* Case 1: the input has not progressed *)
        injection Htmcloop_succeeds as <-. apply tree_check_fail.
        rewrite ms_suffix_current_str with (ms := ms1) by assumption.
        unfold ms_suffix.
        rewrite Z.eqb_eq in Heqcheck.
        rewrite Heqcheck.
        replace (MatchState.input ms1) with (MatchState.input ms).
        2: {
          eapply inp_compat_ms_same_inp with (inp1 := inp) (inp2 := inp'); eauto.
        }
        reflexivity.                                               
      - (* Case 2: the input has progressed *)
        destruct tRepeatMatcher' as [subtree|] eqn:Heqsubtree; simpl in *.
        2: discriminate.
        injection Htmcloop_succeeds as <-.
        apply tree_check.
        + eapply endInd_neq_advanced; eauto.
        + rewrite noi_decr in Heqsubtree. specialize (IHfuel (delta - 1)%NoI tmc gl actions str0 Hgldisj Htmc_valid inp' Hinp'_compat ms1 gm1 subtree Hms1inp Heqsubtree Hgm1ms1 Hgm1gl). apply IHfuel.
    }
    unfold tm_valid in Htmvalid.
    specialize (Htmvalid tmcloop gl (Acheck (ms_suffix ms dir)::Areg (Regex.Quantified greedy 0 (delta-1)%NoI lreg)::actions) str0 Hgldisj Htmcloop_valid inp Hinp_compat).
    specialize (Htmc_valid inp Hinp_compat).
    unfold tMC_is_tree in Htmvalid, Htmc_valid.
    assert (ms_matches_inp msreset inp) as Hmsreset_inp. {
      unfold msreset. inversion Hmsinp. simpl. now constructor.
    }

    destruct greedy.
    + (* Greedy star *)
      destruct tm as [z|] eqn:Heqz; simpl. 2: discriminate.
      destruct tmc as [z'|] eqn:Heqz'; simpl. 2: discriminate.
      specialize (Htmvalid msreset (GroupMap.reset (seq (parenIndex + 1) parenCount) gm) z Hmsreset_inp Heqz).
      specialize_prove Htmvalid by admit.
      specialize_prove Htmvalid by admit.
      specialize (Htmc_valid ms gm z' Hmsinp Heqz' Hgmms Hgmgl).
      rewrite noi_nonzero_succprec with (x := delta). 2: now apply noi_eqb_neq.
      eapply tree_quant_free.
      * symmetry. apply Hgroupsvalid.
      * rewrite ms_suffix_current_str with (ms := ms). 2: assumption.
        apply Htmvalid.
      * apply Htmc_valid.
      * inversion HmatchSuccess. reflexivity.

    + (* Lazy star *)
      destruct tmc as [z'|] eqn:Heqz'; simpl. 2: discriminate.
      destruct tm as [z|] eqn:Heqz; simpl. 2: discriminate.
      specialize (Htmvalid msreset (GroupMap.reset (seq (parenIndex + 1) parenCount) gm) z Hmsreset_inp Heqz).
      specialize_prove Htmvalid by admit.
      specialize_prove Htmvalid by admit.
      specialize (Htmc_valid ms gm z' Hmsinp Heqz' Hgmms Hgmgl).
      rewrite noi_nonzero_succprec with (x := delta). 2: now apply noi_eqb_neq.
      eapply tree_quant_free.
      * symmetry. apply Hgroupsvalid.
      * rewrite ms_suffix_current_str with (ms := ms). 2: assumption.
        apply Htmvalid.
      * apply Htmc_valid.
      * inversion HmatchSuccess. reflexivity.
  Admitted.

  (* Main theorem for repeated matching *)
  Lemma tRepeatMatcher'_valid:
    (* for all repeat matcher parameters, *)
    forall rer greedy parenIndex parenCount mini delta,
      (* for any TMatcher tm that is valid with respect to some Linden regex lreg and direction dir, *)
    forall (tm: TMatcher) (lreg: regex) (dir: Direction),
      tm_valid tm rer lreg dir ->
      (* such that the defined groups of lreg correspond to the capture reset parameters of the repeat matcher, *)
      def_groups lreg = List.seq (parenIndex + 1) parenCount ->
      (* the corresponding tree repeat matcher recognizes lreg quantified accordingly to the parameters (for any fuel, provided the matcher does not run out of fuel) with direction dir. *)
      forall fuel, tm_valid (fun s tmc => tRepeatMatcher' tm dir mini (NoI.N mini + delta)%NoI greedy s tmc parenIndex parenCount fuel) rer (Regex.Quantified greedy mini delta lreg) dir.
  Proof.
    intros rer greedy parenIndex parenCount mini delta tm lreg dir Htmvalid Hgroupsvalid fuel.
    destruct mini as [|mini'].
    - replace (NoI.N 0 + delta)%NoI with delta by now destruct delta. now apply tRepeatMatcher'_free_valid.
    - apply tRepeatMatcher'_forced_valid; auto. intro fuel0. now apply tRepeatMatcher'_free_valid.
  Qed.


  (** ** Lemma for lookarounds *)
  Lemma tLookaroundMatcher_pt:
    (* lkdir: lookaround direction, pos: lookaround positivity *)
    (* lkwreg: Warblre lookaround regexp, lklreg: Linden lookaround regexp *)
    (* ctx: context of the entire lookaround regexp *)
    (* direction: direction of matching of the "parent" regexp of the lookaround *)
    (* n: number of parentheses before the lookaround regexp in the context *)
    (* wroot: the root Warblre regexp *)
    (* The hypotheses are written such that eapply then eauto works when proving the lookaround cases of the main theorem. *)
    forall lkdir pos lkwreg lklreg ctx rer direction tm n wroot
      (Hequiv: equiv_regex' lkwreg lklreg n)
      (Heqn: n = StaticSemantics.countLeftCapturingParensBefore (to_warblre_lookaround lkdir pos lkwreg) ctx)
      (Hroot: Root wroot (to_warblre_lookaround lkdir pos lkwreg, ctx))
      (IH: forall ctx, Root wroot (lkwreg, ctx) -> n = StaticSemantics.countLeftCapturingParensBefore lkwreg ctx -> forall tmlk dir, tCompileSubPattern lkwreg ctx rer dir = Success tmlk -> tm_valid tmlk rer lklreg dir)
      (Hcompilesucc: tLookaroundMatcher tCompileSubPattern lkdir pos lkwreg ctx rer direction = Success tm),
      tm_valid tm rer (Lookaround (to_lookaround lkdir pos) lklreg) direction.
  Proof.
    intros.
    specialize (IH (lkCtx lkdir pos :: ctx)).
    specialize_prove IH. {
      destruct lkdir; destruct pos; simpl in *; eauto using same_root_down0, Down_Lookahead_inner, Down_Lookbehind_inner, Down_NegativeLookahead_inner, Down_NegativeLookbehind_inner.
    }
    specialize_prove IH. {
      unfold StaticSemantics.countLeftCapturingParensBefore in *.
      destruct lkdir; destruct pos; simpl in *; lia.
    }
    unfold tLookaroundMatcher in Hcompilesucc.
    destruct tCompileSubPattern as [tmlk|] eqn:Hcompilelksucc; simpl in *. 2: discriminate.
    injection Hcompilesucc as <-. specialize (IH tmlk lkdir Hcompilelksucc).
    unfold tm_valid in *. specialize (IH id_tmcont [] []).
    intros tmc gl actions str0 Hgldisj Htmcvalid.
    specialize (IH str0). specialize_prove IH by admit. specialize (IH (id_tmcont_valid rer str0 lkdir)). unfold tMC_valid in *.
    intros inp Hinpcompat. unfold tMC_is_tree. intros ms gm t Hmsinp.
    unfold tMC_is_tree in IH. specialize (IH inp Hinpcompat ms (to_group_map ms)).
    destruct (tmlk ms _) as [tlk|] eqn:Htlk; simpl. 2: discriminate.
    specialize (IH tlk Hmsinp eq_refl).
    do 2 specialize_prove IH by admit.
    destruct pos; simpl.
    - (* Positive lookaround *)
      destruct tree_res as [gmlk|] eqn:Hgmlk; simpl.
      + (* Lookaround succeeds *)
        specialize (Htmcvalid inp Hinpcompat).
        set (msafterlk := match_state _ _ _). specialize (Htmcvalid msafterlk).
        destruct (tmc msafterlk) as [tafterlk|]; simpl. 2: discriminate.
        set (gmafterlk_opt := tree_res tlk gm (Z.to_nat (MatchState.endIndex ms)) lkdir).
        destruct gmafterlk_opt as [gmafterlk|] eqn:Hgmafterlk. 2: admit. (* Absurd because of group map irrelevance *) 
        specialize (Htmcvalid gmafterlk tafterlk).
        specialize_prove Htmcvalid. { unfold msafterlk. inversion Hmsinp. now constructor. }
        specialize (Htmcvalid eq_refl).
        do 2 specialize_prove Htmcvalid by admit.
        intro H. injection H as <-. intros Hgmms Hgmgl.
        apply tree_lk with (gmlk := gmafterlk).
        * rewrite lkdir_to_lookaround. (* Adding open groups does not change anything *) admit. (* now inversion IH. *)
        * unfold lk_result. rewrite positivity_to_lookaround. unfold first_branch.
          destruct (tree_res tlk GroupMap.empty 0 forward) eqn:Heqdummy. 1: eauto.
          admit. (* Need to prove group map irrelevance *) (*apply TreeMSInterp.result_indep_gm with (ms2 := ms) (gl2 := []) (dir2 := lkdir) in Heqdummy. congruence.*)
        * unfold lk_group_map. rewrite positivity_to_lookaround. replace (lk_dir _) with lkdir by now destruct lkdir. (* Sort of apply Hgmlk, which uses a more restricted group map and a Z.to_nat as index *) admit.
        * assumption.
      + (* Lookaround fails *)
        intro H. injection H as <-. intros Hgmms Hgmgl.
        apply tree_lk_fail.
        * rewrite lkdir_to_lookaround. (* Apply IH which uses a more restricted group map *) admit.
        * unfold lk_result. rewrite positivity_to_lookaround. unfold first_branch.
          (* Group map independence *)
          admit.
    - (* Negative lookaround *)
      (* gmlk' is the group map after the lookaround, but without the currently open groups *)
      destruct tree_res as [gmlk'|] eqn:Hgmlk; simpl.
      + (* Lookaround succeeds *)
        intro H. injection H as <-. intros Hgmms Hgmgl.
        apply tree_lk_fail.
        1: rewrite lkdir_to_lookaround; admit. (* Morally, apply IH which uses a more restricted group map *)
        unfold lk_result, first_branch. simpl. rewrite positivity_to_lookaround. intro H.
        (*apply TreeMSInterp.result_indep_gm with (ms2 := ms) (gl2 := []) (dir2 := lkdir) in H. congruence.*) (* Need to prove group map independence *) admit.
      + (* Lookaround fails *)
        specialize (Htmcvalid inp Hinpcompat ms gm).
        destruct (tmc ms) as [tnext|] eqn:Heqnext; simpl. 2: discriminate.
        intro H. injection H as <-.
        specialize (Htmcvalid tnext Hmsinp eq_refl).
        intros Hgmms Hgmgl. specialize (Htmcvalid Hgmms Hgmgl).
        apply tree_lk with (gmlk := gm); auto.
        1: rewrite lkdir_to_lookaround; admit. (* Morally, apply IH which uses a more restricted group map *)
        * unfold lk_result, first_branch. rewrite positivity_to_lookaround.
          (* Group map independence *)
          admit.
        * unfold lk_group_map. rewrite positivity_to_lookaround. reflexivity.
  Admitted.


  (** ** Lemmas for character descriptors *)
  Lemma exist_canonicalized_contains:
    forall rer charset chr,
    RegExpRecord.ignoreCase rer = false ->
    CharSet.exist_canonicalized rer charset (Character.canonicalize rer chr) = CharSet.contains charset chr.
  Proof.
    intros rer charset chr Hcasesenst.
    rewrite CharSet.exist_canonicalized_equiv. simpl.
    apply Bool.eq_true_iff_eq.
    setoid_rewrite CharSetExt.exist_spec. split.
    - intros [c [Hcontains Heq]]. setoid_rewrite canonicalize_casesenst in Heq. 2,3: assumption. rewrite EqDec.inversion_true in Heq. subst c. now apply CharSetExt.contains_spec.
    - intro Hcontains. exists chr. split. 1: now apply CharSetExt.contains_spec.
      apply EqDec.reflb.
  Qed.

  Lemma charSetMatcher_noninv_pt:
    forall charset cd,
    equiv_cd_charset cd charset ->
    forall rer tm dir,
    RegExpRecord.ignoreCase rer = false ->
    tm = tCharacterSetMatcher rer charset false dir ->
    tm_valid tm rer (Regex.Character cd) dir.
  Proof.
    intros charset cd Hequiv rer tm dir Hcasesenst Heqtm. subst tm.
    unfold tm_valid. intros tmc gl actions str0 Hgldisj Htmcvalid.
    unfold tMC_valid. intros inp Hinpcompat. unfold tMC_is_tree. intros ms gm t Hmsinp.
    unfold tCharacterSetMatcher. simpl.
    set (nextend := if (dir ==? forward)%wt then _ else _).
    set (next_outofbounds := ((_ <? 0)%Z || _)%bool).
    destruct next_outofbounds eqn:Hoob; simpl.
    + intro Htm_succ. injection Htm_succ as <-. intros Hgmms Hgmgl.
      apply tree_char_fail.
      destruct dir; simpl in *.
      * eapply read_oob_fail_end_bool; eauto. * eapply read_oob_fail_begin_bool; eauto.
    + (* If we are in bounds, then getting the character should succeed. Since we don't prove anything in the case of errors, we just assume this here *)
      destruct List.List.Indexing.Int.indexing as [chr|err] eqn:Hgetchr; simpl in *. 2: discriminate.
      setoid_rewrite exist_canonicalized_contains. 2: assumption.
      specialize (Hequiv chr) as Hequivchr.
      pose proof next_inbounds_nextinp ms inp dir nextend Hmsinp eq_refl Hoob as Hnextinp.
      destruct Hnextinp as [inp_adv Hnextinp].
      destruct CharSet.contains; simpl in *.
      * (* Case 1: the character matches. We then want to prove that we have a read success. *)
        intros Htm_succ Hgmms Hgmgl.
        (* We first need to replace t with Success (Read chr child). *)
        remember (match_state _ _ _) as ms_adv in Htm_succ.
        unfold tMC_valid, tMC_is_tree in Htmcvalid.
        destruct (tmc ms_adv) as [child|] eqn:Htmc_succ; simpl in *. 2: discriminate.
        injection Htm_succ as <-.

        (* Now we apply tree_char with the next input. *)      
        apply tree_char with (nextinp := inp_adv).
        1: {
          unfold read_char.
          eapply read_char_success; eauto.
          2: { rewrite exist_canonicalized_contains by assumption. pose proof Hequiv chr as Hequivchr'. congruence. }
          destruct dir; simpl in *.
          - replace (Z.min _ _) with (MatchState.endIndex ms) in Hgetchr by lia. apply Hgetchr.
          - replace (Z.min _ _) with nextend in Hgetchr by lia. apply Hgetchr.
        }
        (* The subtree is valid: results from three lemmas. *)
        apply Htmcvalid with (ms := ms_adv); auto.
        -- eapply advance_input_compat; eassumption.
        -- eapply ms_matches_inp_adv; eauto.
           destruct dir; unfold advance_ms; subst ms_adv; simpl in *; reflexivity.
        -- subst ms_adv. apply Hgmms.
      * (* Case 2: it is not equal. *)
        intro Htm_succ. injection Htm_succ as <-. intros Hgmms Hgmgl.
        apply tree_char_fail.
        eapply read_char_fail; eauto.
        2: { rewrite exist_canonicalized_contains by assumption. pose proof Hequiv chr as Hequivchr'. rewrite Hequivchr in Hequivchr'. symmetry in Hequivchr'. eassumption. }
        destruct dir; simpl in *.
        -- replace (Z.min _ _) with (MatchState.endIndex ms) in Hgetchr by lia. auto.
        -- replace (Z.min _ _) with nextend in Hgetchr by lia. auto.
  Qed.

  (* TODO Factorize with non-inverted case? *)
  Lemma charSetMatcher_inv_pt:
    forall charset cd,
    equiv_cd_charset cd charset ->
    forall rer tm dir,
    RegExpRecord.ignoreCase rer = false ->
    tm = tCharacterSetMatcher rer charset true dir ->
    tm_valid tm rer (Regex.Character (CdInv cd)) dir.
  Proof.
    intros charset cd Hequiv rer tm dir Hcasesenst Heqtm. subst tm.
    unfold tm_valid. intros tmc gl actions str0 Hgldisj Htmcvalid.
    unfold tMC_valid. intros inp Hinpcompat. unfold tMC_is_tree. intros ms gm t Hmsinp.
    unfold tCharacterSetMatcher. simpl.
    set (nextend := if (dir ==? forward)%wt then _ else _).
    set (next_outofbounds := ((_ <? 0)%Z || _)%bool).
    destruct next_outofbounds eqn:Hoob; simpl.
    + intro Htm_succ. injection Htm_succ as <-. intros Hgmms Hgmgl.
      apply tree_char_fail.
      destruct dir; simpl in *.
      * eapply read_oob_fail_end_bool; eauto. * eapply read_oob_fail_begin_bool; eauto.
    + (* If we are in bounds, then getting the character should succeed. Since we don't prove anything in the case of errors, we just assume this here *)
      destruct List.List.Indexing.Int.indexing as [chr|err] eqn:Hgetchr; simpl in *. 2: discriminate.
      setoid_rewrite exist_canonicalized_contains. 2: assumption.
      specialize (Hequiv chr) as Hequivchr.
      pose proof next_inbounds_nextinp ms inp dir nextend Hmsinp eq_refl Hoob as Hnextinp.
      destruct Hnextinp as [inp_adv Hnextinp].
      destruct CharSet.contains; simpl in *.
      * (* Case 1: the character matches. *)
        intro Htm_succ. injection Htm_succ as <-. intros Hgmms Hgmgl.
        apply tree_char_fail.
        eapply read_char_success; eauto.
        2: { rewrite exist_canonicalized_contains by assumption. pose proof Hequiv chr as Hequivchr'. rewrite Hequivchr in Hequivchr'. symmetry in Hequivchr'. eassumption. }
        destruct dir; simpl in *.
        -- replace (Z.min _ _) with (MatchState.endIndex ms) in Hgetchr by lia. auto.
        -- replace (Z.min _ _) with nextend in Hgetchr by lia. auto.
      * (* Case 2: the character doesn't match. We then want to prove that we have a read success. *)
        intros Htm_succ Hgmms Hgmgl.
        (* We first need to replace t with Success (Read chr child). *)
        remember (match_state _ _ _) as ms_adv in Htm_succ.
        unfold tMC_valid, tMC_is_tree in Htmcvalid.
        destruct (tmc ms_adv) as [child|] eqn:Htmc_succ; simpl in *. 2: discriminate.
        injection Htm_succ as <-.

        (* Now we apply tree_char with the next input. *)
        apply tree_char with (nextinp := inp_adv).
        1: {
          unfold read_char.
          eapply read_char_fail; eauto.
          2: { rewrite exist_canonicalized_contains by assumption. pose proof Hequiv chr as Hequivchr'. congruence. }
          destruct dir; simpl in *.
          - replace (Z.min _ _) with (MatchState.endIndex ms) in Hgetchr by lia. apply Hgetchr.
          - replace (Z.min _ _) with nextend in Hgetchr by lia. apply Hgetchr.
        }
        (* The subtree is valid: results from three lemmas. *)
        apply Htmcvalid with (ms := ms_adv); auto.
        -- eapply advance_input_compat; eassumption.
        -- eapply ms_matches_inp_adv; eauto.
           destruct dir; unfold advance_ms; subst ms_adv; simpl in *; reflexivity.
        -- subst ms_adv. auto.
  Qed.

  (* Lemma for character class escapes *)
  Lemma characterclassescape_pt:
    forall (rer: RegExpRecord) (lroot: regex) (wroot: Regex)
      (root_equiv: equiv_regex wroot lroot),
      RegExpRecord.ignoreCase rer = false ->
    forall esc wreg lreg ctx,
      wreg = AtomEsc (ACharacterClassEsc esc) ->
      Root wroot (wreg, ctx) ->
      equiv_regex' wreg lreg (StaticSemantics.countLeftCapturingParensBefore wreg ctx) ->
      forall tm dir,
        tCompileSubPattern wreg ctx rer dir = Success tm ->
        tm_valid tm rer lreg dir.
  Proof.
    intros rer lroot wroot root_equiv Hcasesenst esc wreg lreg ctx Heqwreg Hroot Hequiv tm dir.
    subst wreg. inversion Hequiv as [| | | esc0 cd n Hequiv' Heqesc0 Heqlreg Heqn | | | | | | | |].
    2: { (* Absurd *) inversion H0; inversion H2; subst; discriminate. }
    2: { (* Absurd *) inversion H; discriminate. }
    subst lreg esc0 n. simpl.
    inversion Hequiv' as [Heqesc Heqcd | Heqesc Heqcd | Heqesc Heqcd | Heqesc Heqcd | Heqesc Heqcd | Heqesc Heqcd]; simpl in *; intro H; injection H as H; eapply charSetMatcher_noninv_pt; eauto; setoid_rewrite CharSetExt.union_empty.
    - apply equiv_cd_digits.
    - apply equiv_cd_inv. apply equiv_cd_digits.
    - apply equiv_cd_whitespace.
    - apply equiv_cd_inv. apply equiv_cd_whitespace.
    - pose proof wordCharacters_casesenst_eq rer Hcasesenst. unfold Semantics.wordCharacters, Coercions.wrap_CharSet in H0. simpl in H0. injection H0 as H0. rewrite H0. apply equiv_cd_wordchar.
    - apply equiv_cd_inv. pose proof wordCharacters_casesenst_eq rer Hcasesenst. unfold Semantics.wordCharacters, Coercions.wrap_CharSet in H0. simpl in H0. injection H0 as H0. rewrite H0. apply equiv_cd_wordchar.
  Qed.

  (* Lemma for character escapes *)
  Lemma characterescape_pt:
    forall (rer: RegExpRecord) (lroot: regex) (wroot: Regex)
      (root_equiv: equiv_regex wroot lroot),
      RegExpRecord.ignoreCase rer = false ->
    forall esc wreg lreg ctx,
      wreg = AtomEsc (ACharacterEsc esc) ->
      Root wroot (wreg, ctx) ->
      equiv_regex' wreg lreg (StaticSemantics.countLeftCapturingParensBefore wreg ctx) ->
      forall tm dir,
        tCompileSubPattern wreg ctx rer dir = Success tm ->
        tm_valid tm rer lreg dir.
  Proof.
    intros rer lroot wroot root_equiv Hcasesenst esc wreg lreg ctx Heqwreg Hroot Hequiv tm dir.
    subst wreg. inversion Hequiv as [| | | | esc0 cd n Hequiv' Heqesc0 Heqlreg Heqn | | | | | | |].
    2: { (* Absurd *) inversion H0; subst; discriminate. }
    2: { (* Absurd *) inversion H; subst; discriminate. }
    inversion Hequiv' as [controlesc cd0 Hequiv'' Heqesc Heqcd0 | l cd0 Hequiv'' Heqesc Heqcd0 | Heqesc Heqcd | d1 d2 Heqesc Heqcd].
    - inversion Hequiv'' as [Heqcontrolesc Heqcd | Heqcontrolesc Heqcd | Heqcontrolesc Heqcd | Heqcontrolesc Heqcd | Heqcontrolesc Heqcd]; simpl; intro H; injection H as H; eapply charSetMatcher_noninv_pt; eauto; unfold nat_to_nni; rewrite Character.numeric_pseudo_bij; apply equiv_cd_single.
    - inversion Hequiv'' as [l0 i Heqi Heql0 Heqcd].
      simpl. rewrite <- Heqi. intro H. injection H as <-.
      eapply charSetMatcher_noninv_pt; eauto. apply equiv_cd_single.
    - simpl; intro H; injection H as H; eapply charSetMatcher_noninv_pt; eauto; unfold nat_to_nni; rewrite Character.numeric_pseudo_bij; apply equiv_cd_single.
    - simpl. intro H. injection H as H. eapply charSetMatcher_noninv_pt; eauto. apply equiv_cd_single.
  Qed.

  (* Lemmas for character classes *)


  Lemma characterclass_pt:
    forall (rer: RegExpRecord) (lroot: regex) (wroot: Regex)
      (root_equiv: equiv_regex wroot lroot),
      RegExpRecord.ignoreCase rer = false ->
    forall cc wreg lreg ctx,
      wreg = CharacterClass cc ->
      Root wroot (wreg, ctx) ->
      equiv_regex' wreg lreg (StaticSemantics.countLeftCapturingParensBefore wreg ctx) ->
      forall tm dir,
        tCompileSubPattern wreg ctx rer dir = Success tm ->
        tm_valid tm rer lreg dir.
  Proof.
    intros rer lroot wroot root_equiv Hcasesenst cc wreg lreg ctx Heqwreg Hroot Hequiv tm dir.
    subst wreg. inversion Hequiv as [| | | | | cc0 cd n Hequiv' Heqcc Heqlreg Heqn | | | | | |].
    2: { inversion H0; subst; discriminate. }
    2: { inversion H; subst; discriminate. }
    inversion Hequiv' as [crs cd0 Hequiv'' Heqcc' Heqcd0 | crs cd0 Hequiv'' Heqcc' Heqcd0]; simpl.
    - pose proof equiv_cd_ClassRanges crs cd rer Hcasesenst Hequiv'' as [a [Heqa Hequiva]]. rewrite Heqa. simpl.
      intro H. injection H as <-. eapply charSetMatcher_noninv_pt; eauto.
    - subst cd. pose proof equiv_cd_ClassRanges crs cd0 rer Hcasesenst Hequiv'' as [a [Heqa Hequiva]]. rewrite Heqa. simpl.
      intro H. injection H as <-. eapply charSetMatcher_inv_pt; eauto.
  Qed.

  (** ** Main theorem *)
  (* We place ourselves in the context of some root regex, and prove the validity for all the sub-regexes of the root regex. *)
  Theorem tmatcher_pt:
    forall (rer: RegExpRecord) (lroot: regex) (wroot: Regex)
      (* Assume that we do not ignore case, *)
      (Hcasesenst: RegExpRecord.ignoreCase rer = false)
      (* that we do not consider line ends and starts to be input ends and starts, respectively, *)
      (Hnomultiline: RegExpRecord.multiline rer = false)
      (* and that dot matches all characters. *)
      (Hdotall: RegExpRecord.dotAll rer = true)
      (* Let lroot and wroot be a pair of equivanent regexes. *)
      (root_equiv: equiv_regex wroot lroot),
      (* Then for any sub-regex wreg of the root Warblre regex, *)
    forall (wreg: Regex) (lreg: regex) ctx,
      Root wroot (wreg, ctx) ->
      (* and any Linden regex lreg that is equivalent to this sub-regex with the right number of left capturing parentheses before, *)
      equiv_regex' wreg lreg (StaticSemantics.countLeftCapturingParensBefore wreg ctx) ->
      forall tm dir,
        (* if tCompileSubPattern with direction dir yields a TMatcher for regex wreg, *)
        tCompileSubPattern wreg ctx rer dir = Success tm ->
        (* then this TMatcher is valid with respect to the regex lreg and direction dir. *)
        tm_valid tm rer lreg dir.
  Proof.
    intros rer lroot wroot Hcasesenst Hnomultiline Hdotall root_equiv wreg lreg ctx Hroot Hequiv.
    remember (StaticSemantics.countLeftCapturingParensBefore _ _) as n in Hequiv.
    revert ctx Hroot Heqn.
    induction Hequiv as [
        n |
        n c |
        n |
        esc cd n Hequivesc |
        esc cd n Hequivesc |
        cc cd n Hequivcc |
        n wr1 wr2 lr1 lr2 Hequiv1 IH1 Hequiv2 IH2 |
        n wr1 wr2 lr1 lr2 Hequiv1 IH1 Hequiv2 IH2 |
        n wr lr wquant lquant wgreedylazy greedy Hequiv IH Hequivquant Hequivgreedy |
        name n wr lr Hequiv IH |
        n wr lr wlk llk Hequiv IH Hequivlk |
        n wr lanchor Hanchequiv
    ].


    - (* Empty *)
      simpl. intros _ _ _.
      intros tm dir Hcompsucc tmc cont str0 Htmc_tree inp Hinp_compat.
      injection Hcompsucc as <-.
      intros ms t Hms_inp Htmc_succ.
      apply tree_pop_reg. unfold tMC_valid, tMC_is_tree in Htmc_tree.
      now apply Htmc_tree with (ms := ms).


    - (* Character *)
      simpl. intros ctx Hroot _ tm dir Hcompile_succ tmc cont str0 Htmc_tree inp Hinp_compat ms t Hms_inp Htm_succ.
      injection Hcompile_succ as Hcompile_succ. symmetry in Hcompile_succ.
      eapply charSetMatcher_noninv_pt; eauto. apply equiv_cd_single.

    (* Dot *)
    - simpl. intros ctx Hroot _ tm dir Hcompile_succ tmc cont str0 Htmc_tree inp Hinp_compat ms t Hms_inp Htm_succ.
      injection Hcompile_succ as Hcompile_succ. symmetry in Hcompile_succ.
      eapply charSetMatcher_noninv_pt; eauto. rewrite Hdotall. apply equiv_cd_dot.


    (* AtomEsc (ACharacterClassEsc esc) *)
    - intros ctx Hroot Heqn tm dir. eapply characterclassescape_pt; eauto.
      constructor. assumption.

    (* AtomEsc (ACharacterEsc esc) *)
    - intros ctx Hroot Heqn tm dir. eapply characterescape_pt; eauto.
      constructor. assumption.

    (* Character class *)
    - intros ctx Hroot Heqn tm dir. eapply characterclass_pt; eauto.
      constructor. assumption.


    - (* Disjunction *)
      intros ctx Hroot Heqn.
      simpl in *.
      specialize (IH1 (Disjunction_left wr2 :: ctx)).
      specialize (IH2 (Disjunction_right wr1 :: ctx)).
      specialize_prove IH1 by eauto using same_root_down0, Down_Disjunction_left.
      specialize_prove IH1. {
        simpl. unfold StaticSemantics.countLeftCapturingParensBefore in *. lia.
      }
      specialize_prove IH2 by eauto using same_root_down0, Down_Disjunction_right.
      specialize_prove IH2. {
        unfold StaticSemantics.countLeftCapturingParensBefore in *. simpl.
        assert (num_groups lr1 = StaticSemantics.countLeftCapturingParensWithin_impl wr1) by (eapply num_groups_equiv; eassumption).
        lia.
      }
      intros tm dir Hcompsucc.
      destruct (tCompileSubPattern wr1 _ rer dir) as [tm1|] eqn:Htm1; simpl. 2: discriminate.
      destruct (tCompileSubPattern wr2 _ rer dir) as [tm2|] eqn:Htm2; simpl. 2: discriminate.
      simpl in Hcompsucc. injection Hcompsucc as <-.
      intros tmc cont str0 Htmc_tree inp Hinp_compat s t Hs_inp Heqt.
      specialize (IH1 tm1 dir Htm1 tmc cont str0 Htmc_tree inp Hinp_compat).
      specialize (IH2 tm2 dir Htm2 tmc cont str0 Htmc_tree inp Hinp_compat).
      destruct (tm1 s tmc) as [t1|] eqn:Heqt1; simpl. 2: discriminate.
      destruct (tm2 s tmc) as [t2|] eqn:Heqt2; simpl. 2: discriminate.
      specialize (IH1 s t1 Hs_inp). specialize (IH2 s t2 Hs_inp).
      simpl in *.
      rewrite Heqt1 in IH1. rewrite Heqt2 in IH2.
      apply tree_pop_reg.
      injection Heqt as <-.
      specialize (IH1 eq_refl). specialize (IH2 eq_refl).
      inversion IH1. inversion IH2.
      now apply tree_disj.


    - (* Sequence *)
      intros ctx Hroot Heqn. simpl in *. intros tm dir Hcompsucc.
      specialize (IH1 (Seq_left wr2 :: ctx)).
      specialize (IH2 (Seq_right wr1 :: ctx)).
      specialize_prove IH1 by eauto using same_root_down0, Down_Seq_left.
      specialize_prove IH1. {
        unfold StaticSemantics.countLeftCapturingParensBefore in *.
        simpl.
        lia.
      }
      specialize_prove IH2 by eauto using same_root_down0, Down_Seq_right.
      specialize_prove IH2. {
        unfold StaticSemantics.countLeftCapturingParensBefore in *.
        simpl.
        assert (H: num_groups lr1 = StaticSemantics.countLeftCapturingParensWithin_impl wr1) by (eapply num_groups_equiv; eassumption).
        lia.
      }
      destruct (tCompileSubPattern wr1 _ rer dir) as [tm1|] eqn:Htm1; simpl. 2: discriminate.
      destruct (tCompileSubPattern wr2 _ rer dir) as [tm2|] eqn:Htm2; simpl. 2: discriminate.
      specialize (IH1 tm1 dir Htm1). specialize (IH2 tm2 dir Htm2).
      intros tmc cont str0 Htmc_tree inp Hinp_compat ms t Hms_inp Heqt.
      simpl in Hcompsucc. destruct dir; injection Hcompsucc as <-.
      + remember (fun s1 => tm2 s1 tmc) as tmc2.
        assert (tMC_valid tmc2 rer (Areg lr2::cont) str0 forward) as Htmc2_tree. {
          intros inp' Hinp'_compat.
          rewrite Heqtmc2.
          unfold tm_valid, tMC_valid in IH2.
          now apply IH2 with (str0 := str0).
        }
        specialize (IH1 tmc2 (Areg lr2 :: cont) str0 Htmc2_tree inp Hinp_compat ms t Hms_inp Heqt).
        apply tree_pop_reg.
        inversion IH1.
        now apply tree_sequence_fwd.
      + remember (fun s2 => tm1 s2 tmc) as tmc1.
        assert (tMC_valid tmc1 rer (Areg lr1::cont) str0 backward) as Htmc1_tree. {
          intros inp' Hinp'_compat.
          rewrite Heqtmc1.
          unfold tm_valid, tMC_valid in IH1.
          now apply IH1 with (str0 := str0).
        }
        specialize (IH2 tmc1 (Areg lr1::cont) str0 Htmc1_tree inp Hinp_compat ms t Hms_inp Heqt).
        apply tree_pop_reg.
        inversion IH2.
        now apply tree_sequence_bwd.


    - (* Quantifier *)
      intros ctx Hroot Heqn. simpl. intros tm dir Hcompsucc.
      destruct tCompileSubPattern as [m|] eqn:Heqm; simpl. 2: discriminate.
      simpl in Hcompsucc.
      intros tmc cont str0 Htmc_valid.
      set (StaticSemantics.countLeftCapturingParensBefore _ ctx) as parenIndex in Hcompsucc.
      set (StaticSemantics.countLeftCapturingParensWithin _ _) as parenCount in Hcompsucc.
      set (Semantics.CompiledQuantifier_min _) as mini in Hcompsucc.
      set (Semantics.CompiledQuantifier_max _) as maxi in Hcompsucc.
      rewrite compilequant_greedy with (lquant := lquant) (greedy := greedy) in Hcompsucc by assumption.
      specialize (IH (Quantified_inner (wgreedylazy wquant)::ctx)).
      specialize_prove IH by eauto using same_root_down0, Down_Quantified_inner.
      specialize_prove IH. {
        unfold StaticSemantics.countLeftCapturingParensBefore in *. simpl. lia.
      }
      specialize (IH m dir Heqm).
      pose proof tRepeatMatcher'_valid rer greedy parenIndex parenCount mini (maxi-mini)%NoI m lr dir IH as Hrepeat.
      specialize_prove Hrepeat. {
        subst n. apply equiv_def_groups with (wr := wr) (ctx := ctx); auto.
      }
      destruct (mini <=? maxi)%NoI eqn:Hmini_le_maxi. 2: discriminate.
      injection Hcompsucc as <-.
      unfold tRepeatMatcher.
      intros inp Hinpcompat ms t Hmsinp Heqt.
      specialize (Hrepeat (Semantics.repeatMatcherFuel mini ms) tmc cont str0 Htmc_valid inp Hinpcompat ms t Hmsinp).
      rewrite noi_add_diff in Hrepeat by assumption. specialize (Hrepeat Heqt).
      inversion Hequivquant as [
          Heqwquant Heqlquant |
          Heqwquant Heqlquant |
          Heqwquant Heqlquant |
          nrep Heqwquant Heqlquant |
          nmin Heqwquant Heqlquant |
          mini' maxi' Hle' Heqwquant Heqlquant]; subst wquant lquant;
      inversion Hequivgreedy as [Heqwgl Heqgreedy | Heqwgl Heqgreedy]; subst wgreedylazy greedy; simpl in *; try apply Hrepeat.
      all: replace (nrep - mini) with 0 in Hrepeat by lia; apply Hrepeat.


    - (* Group *)
      intros ctx Hroot Heqn. simpl. intros tm dir Hcompsucc.
      specialize (IH (Group_inner name :: ctx)).
      specialize_prove IH by eauto using same_root_down0, Down_Group_inner.
      specialize_prove IH. {
        unfold StaticSemantics.countLeftCapturingParensBefore in *. simpl. lia.
      }
      destruct (tCompileSubPattern wr _ rer dir) as [mr|] eqn:Heqmr; simpl. 2: discriminate.
      specialize (IH mr dir Heqmr).
      simpl in Hcompsucc. injection Hcompsucc as <-.
      intros tmc cont str0 Htmc_tree inp Hinp_compat ms t Hms_inp Heqt.
      remember (fun y: MatchState => _) as tmc2 in Heqt.
      specialize (IH tmc2 (Aclose (S n) :: cont)).
      assert (StaticSemantics.countLeftCapturingParensBefore (Group name wr) ctx + 1 = S n) as Heqid by lia.
      assert (tMC_valid tmc2 rer (Aclose (S n) :: cont) str0 dir) as Htmc2_tree.
      {
        intros inpend Hinpend_compat.
        subst tmc2. clear Heqt.
        unfold tMC_is_tree.
        intros msend subtree Hmsend_inp Heqsubtree.
        remember (if (dir ==? forward)%wt then _ else _) as rres. destruct rres as [r|] eqn:Hrres; simpl in *. 2: discriminate.
        rewrite Heqid in Heqsubtree. change ((S n) =? 0) with false in Heqsubtree.
        destruct (List.List.Update.Nat.One.update) as [cap|] eqn:Heqcap; simpl in *. 2: discriminate.
        specialize (Htmc_tree inpend Hinpend_compat).
        unfold tMC_is_tree in Htmc_tree.
        remember (match_state _ _ cap) as msupd. specialize (Htmc_tree msupd).
        replace (MatchState.input ms) with str0 in *.
        2: { symmetry. eapply inp_compat_ms_str0. - apply Hinp_compat. - apply Hms_inp. }
        assert (MatchState.input msend = str0) as Hmsendstr0. {
          eapply inp_compat_ms_str0. - apply Hinpend_compat. - assumption.
        }
        destruct (tmc msupd) as [subtree'|] eqn:Heqsubtree'; simpl in *. 2: discriminate.
        injection Heqsubtree as <-.
        specialize (Htmc_tree subtree').
        assert (ms_matches_inp msupd inpend) as Hmsupd_inp'. {
          subst msupd.
          eapply ms_matches_inp_capchg with (cap := MatchState.captures msend).
          rewrite <- Hmsendstr0. now destruct msend.
        }
        specialize (Htmc_tree Hmsupd_inp' eq_refl).
        apply tree_pop_close. assumption.
      }
      specialize (IH str0 Htmc2_tree inp Hinp_compat ms).
      apply tree_pop_reg.
      destruct (mr ms tmc2) as [subtree|] eqn:Heqsubtree; simpl in *. 2: discriminate.
      injection Heqt as <-.
      rewrite Heqid.
      apply tree_group.
      specialize (IH subtree Hms_inp eq_refl). inversion IH. assumption.

    - (* Lookarounds *)
      (* We use the lemma tLookaroundMatcher_pt *)
      inversion Hequivlk as [Heqwlk Heqllk | Heqwlk Heqllk | Heqwlk Heqllk | Heqwlk Heqllk]; simpl; intros.
      + eapply tLookaroundMatcher_pt with (lkdir := forward) (pos := true); eauto.
      + eapply tLookaroundMatcher_pt with (lkdir := forward) (pos := false); eauto.
      + eapply tLookaroundMatcher_pt with (lkdir := backward) (pos := true); eauto.
      + eapply tLookaroundMatcher_pt with (lkdir := backward) (pos := false); eauto.

    - (* Anchors *)
      inversion Hanchequiv as [Heqwr Heqlanchor | Heqwr Heqlanchor | Heqwr Heqlanchor | Heqwr Heqlanchor]; simpl.

      + (* Input start *)
        intros ctx Hroot Heqn tm dir Heqtm. injection Heqtm as <-.
        unfold tm_valid. intros tmc cont str0 Htmcvalid inp Hinpcompat ms t Hmsinp.
        rewrite Hnomultiline. simpl.
        destruct (MatchState.endIndex ms =? 0)%Z eqn:Hatbegin; simpl.
        * rewrite Z.eqb_eq in Hatbegin. unfold tMC_valid in Htmcvalid. specialize (Htmcvalid inp Hinpcompat ms).
          destruct (tmc ms) as [subtree|]; simpl in *. 2: discriminate.
          specialize (Htmcvalid subtree Hmsinp eq_refl).
          intro H. injection H as <-.
          apply tree_pop_reg. apply tree_anchor. 2: assumption.
          unfold anchor_satisfied.
          pose proof begin_input_pref_empty _ _ Hatbegin Hmsinp as Hprefnil. now destruct Hprefnil as [next ->].
        * intro H. injection H as <-.
          apply tree_pop_reg. apply tree_anchor_fail. unfold anchor_satisfied.
          rewrite Z.eqb_neq in Hatbegin.
          pose proof begin_input_pref_nonempty _ _ Hatbegin Hmsinp as Hprefnotnil. now destruct Hprefnotnil as [next [x [pref ->]]].

      + (* Input end *)
        intros ctx Hroot Heqn tm dir Heqtm. injection Heqtm as <-.
        unfold tm_valid. intros tmc cont str0 Htmcvalid inp Hinpcompat ms t Hmsinp.
        rewrite Hnomultiline. simpl.
        destruct (MatchState.endIndex ms =? _)%Z eqn:Hatend; simpl.
        * rewrite Z.eqb_eq in Hatend. specialize (Htmcvalid inp Hinpcompat ms).
          destruct (tmc ms) as [subtree|]; simpl in *. 2: discriminate.
          specialize (Htmcvalid subtree Hmsinp eq_refl).
          intro H. injection H as <-.
          apply tree_pop_reg. apply tree_anchor. 2: assumption.
          unfold anchor_satisfied.
          pose proof end_input_next_empty _ _ Hatend Hmsinp as Hnextnil. now destruct Hnextnil as [pref ->].
        * rewrite Z.eqb_neq in Hatend.
          intro H. injection H as <-.
          apply tree_pop_reg. apply tree_anchor_fail. unfold anchor_satisfied.
          pose proof end_input_next_nonempty _ _ Hatend Hmsinp as Hnextnotnil. now destruct Hnextnotnil as [pref [x [next ->]]].

      + (* Word boundary *)
        intros ctx Hroot Heqn tm dir Heqtm. injection Heqtm as <-.
        unfold tm_valid. intros tmc cont str0 Htmcvalid.
        unfold tMC_valid. intros inp Hinpcompat ms t Hmsinp Heqt.
        destruct Semantics.isWordChar as [a|] eqn:Hwca; simpl in *. 2: discriminate.
        destruct (Semantics.isWordChar rer (_ ms) (MatchState.endIndex ms)) as [b|] eqn:Hwcb; simpl in *. 2: discriminate.
        rewrite ifthenelse_xorb in Heqt. pose proof is_boundary_xorb _ _ _ _ _ Hcasesenst Hmsinp Hwca Hwcb as Hisboundary.
        destruct xorb.
        * (* We are on a boundary *)
          unfold tMC_valid in Htmcvalid. specialize (Htmcvalid inp Hinpcompat ms).
          destruct (tmc ms) as [subtree|] eqn:Hsubtree; simpl in *. 2: discriminate.
          specialize (Htmcvalid subtree Hmsinp eq_refl). injection Heqt as <-.
          apply tree_pop_reg. apply tree_anchor. 2: assumption. unfold anchor_satisfied.
          destruct inp as [next pref]. congruence.
        * (* We are not *)
          apply tree_pop_reg. injection Heqt as <-. apply tree_anchor_fail.
          unfold anchor_satisfied. destruct inp as [next pref]; unfold LindenParameters in *; simpl in *; congruence.

      + (* Non word boundary *)
        intros ctx Hroot Heqn tm dir Heqtm. injection Heqtm as <-.
        intros tmc cont str0 Htmcvalid inp Hinpcompat ms t Hmsinp Heqt.
        destruct Semantics.isWordChar as [a|] eqn:Hwca; simpl in *. 2: discriminate.
        destruct (Semantics.isWordChar rer (_ ms) (MatchState.endIndex ms)) as [b|] eqn:Hwcb; simpl in *. 2: discriminate.
        rewrite ifthenelse_negb_xorb in Heqt. pose proof is_boundary_xorb _ _ _ _ _ Hcasesenst Hmsinp Hwca Hwcb as Hisboundary.
        destruct xorb.
        * (* We are on a boundary *)
          simpl in Heqt. injection Heqt as <-.
          apply tree_pop_reg. apply tree_anchor_fail. unfold anchor_satisfied. destruct inp as [next pref].
          setoid_rewrite <- Hisboundary. reflexivity.
        * (* We are not *)
          specialize (Htmcvalid inp Hinpcompat ms).
          destruct (tmc ms) as [subtree|] eqn:Hsubtree; simpl in *. 2: discriminate.
          specialize (Htmcvalid subtree Hmsinp eq_refl). injection Heqt as <-.
          apply tree_pop_reg. apply tree_anchor. 2: assumption. unfold anchor_satisfied.
          destruct inp as [next pref]. rewrite <- Hisboundary. reflexivity.
  Qed.
End LWEquivTree.
